{"version":3,"file":"lokiPlugin.e27ef9683b776a9e8e93.js","mappings":"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","sources":["webpack://grafana/./.yarn/cache/uuid-npm-8.3.0-2f98335399-b539886e6a.zip/node_modules/uuid/dist/esm-browser/parse.js","webpack://grafana/./.yarn/cache/uuid-npm-8.3.0-2f98335399-b539886e6a.zip/node_modules/uuid/dist/esm-browser/sha1.js","webpack://grafana/./.yarn/cache/uuid-npm-8.3.0-2f98335399-b539886e6a.zip/node_modules/uuid/dist/esm-browser/v5.js","webpack://grafana/./.yarn/cache/uuid-npm-8.3.0-2f98335399-b539886e6a.zip/node_modules/uuid/dist/esm-browser/v35.js","webpack://grafana/./public/app/plugins/datasource/loki/query_utils.ts","webpack://grafana/./public/app/plugins/datasource/loki/types.ts","webpack://grafana/./public/app/plugins/datasource/loki/result_transformer.ts","webpack://grafana/./.yarn/cache/rxjs-npm-7.3.0-8a14d1c3d9-e63adb8808.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/WebSocketSubject.js","webpack://grafana/./public/app/plugins/datasource/loki/live_streams.ts","webpack://grafana/./.yarn/cache/rxjs-npm-7.3.0-8a14d1c3d9-e63adb8808.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/webSocket.js","webpack://grafana/./public/app/plugins/datasource/loki/importing/fromGraphite.ts","webpack://grafana/./public/app/plugins/datasource/loki/language_provider.ts","webpack://grafana/./public/app/plugins/datasource/loki/datasource.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiCheatSheet.tsx","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiExploreQueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiQueryEditorForAlerting.tsx","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiQueryEditorByApp.tsx","webpack://grafana/./public/app/plugins/datasource/loki/LokiAnnotationsQueryCtrl.tsx","webpack://grafana/./public/app/plugins/datasource/loki/configuration/MaxLinesField.tsx","webpack://grafana/./public/app/plugins/datasource/loki/configuration/DerivedField.tsx","webpack://grafana/./public/app/plugins/datasource/loki/configuration/DebugSection.tsx","webpack://grafana/./public/app/plugins/datasource/loki/configuration/DerivedFields.tsx","webpack://grafana/./public/app/plugins/datasource/loki/configuration/ConfigEditor.tsx","webpack://grafana/./public/app/plugins/datasource/loki/module.ts"],"sourcesContent":["import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  var v;\n  var arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;","// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n\n    M[_i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nvar v5 = v35('v5', 0x50, sha1);\nexport default v5;","import stringify from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function (name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    var bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (var i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return stringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","import { escapeRegExp } from 'lodash';\nimport { PIPE_PARSERS } from './syntax';\n\nexport function formatQuery(selector: string | undefined): string {\n  return `${selector || ''}`.trim();\n}\n\n/**\n * Returns search terms from a LogQL query.\n * E.g., `{} |= foo |=bar != baz` returns `['foo', 'bar']`.\n */\nexport function getHighlighterExpressionsFromQuery(input: string): string[] {\n  let expression = input;\n  const results = [];\n\n  // Consume filter expression from left to right\n  while (expression) {\n    const filterStart = expression.search(/\\|=|\\|~|!=|!~/);\n    // Nothing more to search\n    if (filterStart === -1) {\n      break;\n    }\n    // Drop terms for negative filters\n    const filterOperator = expression.substr(filterStart, 2);\n    const skip = expression.substr(filterStart).search(/!=|!~/) === 0;\n    expression = expression.substr(filterStart + 2);\n    if (skip) {\n      continue;\n    }\n    // Check if there is more chained\n    const filterEnd = expression.search(/\\|=|\\|~|!=|!~/);\n    let filterTerm;\n    if (filterEnd === -1) {\n      filterTerm = expression.trim();\n    } else {\n      filterTerm = expression.substr(0, filterEnd).trim();\n      expression = expression.substr(filterEnd);\n    }\n\n    const quotedTerm = filterTerm.match(/\"(.*?)\"/);\n    const backtickedTerm = filterTerm.match(/`(.*?)`/);\n    const term = quotedTerm || backtickedTerm;\n\n    if (term) {\n      const unwrappedFilterTerm = term[1];\n      const regexOperator = filterOperator === '|~';\n\n      // Only filter expressions with |~ operator are treated as regular expressions\n      if (regexOperator) {\n        // When using backticks, Loki doesn't require to escape special characters and we can just push regular expression to highlights array\n        // When using quotes, we have extra backslash escaping and we need to replace \\\\ with \\\n        results.push(backtickedTerm ? unwrappedFilterTerm : unwrappedFilterTerm.replace(/\\\\\\\\/g, '\\\\'));\n      } else {\n        // We need to escape this string so it is not matched as regular expression\n        results.push(escapeRegExp(unwrappedFilterTerm));\n      }\n    } else {\n      return results;\n    }\n  }\n\n  return results;\n}\n\nexport function queryHasPipeParser(expr: string): boolean {\n  const parsers = PIPE_PARSERS.map((parser) => `${parser.label}`).join('|');\n  const regexp = new RegExp(`\\\\\\|\\\\\\s?(${parsers})`);\n  return regexp.test(expr);\n}\n\nexport function addParsedLabelToQuery(expr: string, key: string, value: string | number, operator: string) {\n  return expr + ` | ${key}${operator}\"${value.toString()}\"`;\n}\n","import { DataQuery, DataSourceJsonData, QueryResultMeta, ScopedVars } from '@grafana/data';\n\nexport interface LokiInstantQueryRequest {\n  query: string;\n  limit?: number;\n  time?: string;\n  direction?: 'BACKWARD' | 'FORWARD';\n}\n\nexport interface LokiRangeQueryRequest {\n  query: string;\n  limit?: number;\n  start?: number;\n  end?: number;\n  step?: number;\n  direction?: 'BACKWARD' | 'FORWARD';\n}\n\nexport enum LokiResultType {\n  Stream = 'streams',\n  Vector = 'vector',\n  Matrix = 'matrix',\n}\n\nexport interface LokiQuery extends DataQuery {\n  expr: string;\n  query?: string;\n  format?: string;\n  reverse?: boolean;\n  legendFormat?: string;\n  valueWithRefId?: boolean;\n  maxLines?: number;\n  resolution?: number;\n  range?: boolean;\n  instant?: boolean;\n  volumeQuery?: boolean;\n}\n\nexport interface LokiOptions extends DataSourceJsonData {\n  maxLines?: string;\n  derivedFields?: DerivedFieldConfig[];\n  alertmanager?: string;\n}\n\nexport interface LokiStats {\n  [component: string]: {\n    [label: string]: number;\n  };\n}\n\nexport interface LokiVectorResult {\n  metric: { [label: string]: string };\n  value: [number, string];\n}\n\nexport interface LokiVectorResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Vector;\n    result: LokiVectorResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiMatrixResult {\n  metric: Record<string, string>;\n  values: Array<[number, string]>;\n}\n\nexport interface LokiMatrixResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Matrix;\n    result: LokiMatrixResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiStreamResult {\n  stream: Record<string, string>;\n  values: Array<[string, string]>;\n}\n\nexport interface LokiStreamResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Stream;\n    result: LokiStreamResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiTailResponse {\n  streams: LokiStreamResult[];\n  dropped_entries?: Array<{\n    labels: Record<string, string>;\n    timestamp: string;\n  }> | null;\n}\n\nexport type LokiResult = LokiVectorResult | LokiMatrixResult | LokiStreamResult;\nexport type LokiResponse = LokiVectorResponse | LokiMatrixResponse | LokiStreamResponse;\n\nexport interface LokiLogsStreamEntry {\n  line: string;\n  ts: string;\n}\n\nexport interface LokiExpression {\n  regexp: string;\n  query: string;\n}\n\nexport type DerivedFieldConfig = {\n  matcherRegex: string;\n  name: string;\n  url?: string;\n  urlDisplayLabel?: string;\n  datasourceUid?: string;\n};\n\nexport interface TransformerOptions {\n  format?: string;\n  legendFormat?: string;\n  step: number;\n  start: number;\n  end: number;\n  query: string;\n  responseListLength: number;\n  refId: string;\n  scopedVars: ScopedVars;\n  meta?: QueryResultMeta;\n  valueWithRefId?: boolean;\n}\n","import { capitalize, groupBy, isEmpty } from 'lodash';\nimport { v5 as uuidv5 } from 'uuid';\nimport { of } from 'rxjs';\n\nimport {\n  FieldType,\n  TimeSeries,\n  Labels,\n  DataFrame,\n  ArrayVector,\n  MutableDataFrame,\n  findUniqueLabels,\n  DataFrameView,\n  DataLink,\n  Field,\n  QueryResultMetaStat,\n  QueryResultMeta,\n  TimeSeriesValue,\n  ScopedVars,\n} from '@grafana/data';\n\nimport { getTemplateSrv, getDataSourceSrv } from '@grafana/runtime';\nimport TableModel from 'app/core/table_model';\nimport { formatQuery, getHighlighterExpressionsFromQuery } from './query_utils';\nimport {\n  LokiRangeQueryRequest,\n  LokiResponse,\n  LokiMatrixResult,\n  LokiVectorResult,\n  TransformerOptions,\n  LokiResultType,\n  LokiStreamResult,\n  LokiTailResponse,\n  LokiQuery,\n  LokiOptions,\n  DerivedFieldConfig,\n  LokiStreamResponse,\n  LokiStats,\n} from './types';\n\nconst UUID_NAMESPACE = '6ec946da-0f49-47a8-983a-1d76d17e7c92';\n\n/**\n * Transforms LokiStreamResult structure into a dataFrame. Used when doing standard queries and newer version of Loki.\n */\nexport function lokiStreamResultToDataFrame(stream: LokiStreamResult, reverse?: boolean, refId?: string): DataFrame {\n  const labels: Labels = stream.stream;\n  const labelsString = Object.entries(labels)\n    .map(([key, val]) => `${key}=\"${val}\"`)\n    .sort()\n    .join('');\n\n  const times = new ArrayVector<string>([]);\n  const timesNs = new ArrayVector<string>([]);\n  const lines = new ArrayVector<string>([]);\n  const uids = new ArrayVector<string>([]);\n\n  // We need to store and track all used uids to ensure that uids are unique\n  const usedUids: { string?: number } = {};\n\n  for (const [ts, line] of stream.values) {\n    // num ns epoch in string, we convert it to iso string here so it matches old format\n    times.add(new Date(parseInt(ts.substr(0, ts.length - 6), 10)).toISOString());\n    timesNs.add(ts);\n    lines.add(line);\n    uids.add(createUid(ts, labelsString, line, usedUids, refId));\n  }\n\n  return constructDataFrame(times, timesNs, lines, uids, labels, reverse, refId);\n}\n\n/**\n * Constructs dataFrame with supplied fields and other data. Also makes sure it is properly reversed if needed.\n */\nfunction constructDataFrame(\n  times: ArrayVector<string>,\n  timesNs: ArrayVector<string>,\n  lines: ArrayVector<string>,\n  uids: ArrayVector<string>,\n  labels: Labels,\n  reverse?: boolean,\n  refId?: string\n) {\n  const dataFrame = {\n    refId,\n    fields: [\n      { name: 'ts', type: FieldType.time, config: { displayName: 'Time' }, values: times }, // Time\n      { name: 'line', type: FieldType.string, config: {}, values: lines, labels }, // Line - needs to be the first field with string type\n      { name: 'id', type: FieldType.string, config: {}, values: uids },\n      { name: 'tsNs', type: FieldType.time, config: { displayName: 'Time ns' }, values: timesNs }, // Time\n    ],\n    length: times.length,\n  };\n\n  if (reverse) {\n    const mutableDataFrame = new MutableDataFrame(dataFrame);\n    mutableDataFrame.reverse();\n    return mutableDataFrame;\n  }\n\n  return dataFrame;\n}\n\n/**\n * Transform LokiResponse data and appends it to MutableDataFrame. Used for streaming where the dataFrame can be\n * a CircularDataFrame creating a fixed size rolling buffer.\n * TODO: Probably could be unified with the logStreamToDataFrame function.\n * @param response\n * @param data Needs to have ts, line, labels, id as fields\n */\nexport function appendResponseToBufferedData(response: LokiTailResponse, data: MutableDataFrame) {\n  // Should we do anything with: response.dropped_entries?\n\n  const streams: LokiStreamResult[] = response.streams;\n  if (!streams || !streams.length) {\n    return;\n  }\n\n  let baseLabels: Labels = {};\n  for (const f of data.fields) {\n    if (f.type === FieldType.string) {\n      if (f.labels) {\n        baseLabels = f.labels;\n      }\n      break;\n    }\n  }\n\n  const tsField = data.fields[0];\n  const tsNsField = data.fields[1];\n  const lineField = data.fields[2];\n  const labelsField = data.fields[3];\n  const idField = data.fields[4];\n\n  // We are comparing used ids only within the received stream. This could be a problem if the same line + labels + nanosecond timestamp came in 2 separate batches.\n  // As this is very unlikely, and the result would only affect live-tailing css animation we have decided to not compare all received uids from data param as this would slow down processing.\n  const usedUids: { string?: number } = {};\n\n  for (const stream of streams) {\n    // Find unique labels\n    const unique = findUniqueLabels(stream.stream, baseLabels);\n    const allLabelsString = Object.entries(stream.stream)\n      .map(([key, val]) => `${key}=\"${val}\"`)\n      .sort()\n      .join('');\n\n    // Add each line\n    for (const [ts, line] of stream.values) {\n      tsField.values.add(new Date(parseInt(ts.substr(0, ts.length - 6), 10)).toISOString());\n      tsNsField.values.add(ts);\n      lineField.values.add(line);\n      labelsField.values.add(unique);\n      idField.values.add(createUid(ts, allLabelsString, line, usedUids, data.refId));\n    }\n  }\n}\n\nfunction createUid(ts: string, labelsString: string, line: string, usedUids: any, refId?: string): string {\n  // Generate id as hashed nanosecond timestamp, labels and line (this does not have to be unique)\n  let id = uuidv5(`${ts}_${labelsString}_${line}`, UUID_NAMESPACE);\n\n  // Check if generated id is unique\n  // If not and we've already used it, append it's count after it\n  if (id in usedUids) {\n    // Increase the count\n    const newCount = usedUids[id] + 1;\n    usedUids[id] = newCount;\n    // Append count to generated id to make it unique\n    id = `${id}_${newCount}`;\n  } else {\n    // If id is unique and wasn't used, add it to usedUids and start count at 0\n    usedUids[id] = 0;\n  }\n  // Return unique id\n  if (refId) {\n    return `${id}_${refId}`;\n  }\n  return id;\n}\n\nfunction lokiMatrixToTimeSeries(matrixResult: LokiMatrixResult, options: TransformerOptions): TimeSeries {\n  const name = createMetricLabel(matrixResult.metric, options);\n  return {\n    target: name,\n    title: name,\n    datapoints: lokiPointsToTimeseriesPoints(matrixResult.values, options),\n    tags: matrixResult.metric,\n    meta: options.meta,\n    refId: options.refId,\n  };\n}\n\nexport function lokiPointsToTimeseriesPoints(\n  data: Array<[number, string]>,\n  options: TransformerOptions\n): TimeSeriesValue[][] {\n  const stepMs = options.step * 1000;\n  const datapoints: TimeSeriesValue[][] = [];\n\n  let baseTimestampMs = options.start / 1e6;\n  for (const [time, value] of data) {\n    let datapointValue: TimeSeriesValue = parseFloat(value);\n\n    if (isNaN(datapointValue)) {\n      datapointValue = null;\n    }\n\n    const timestamp = time * 1000;\n    for (let t = baseTimestampMs; t < timestamp; t += stepMs) {\n      datapoints.push([null, t]);\n    }\n\n    baseTimestampMs = timestamp + stepMs;\n    datapoints.push([datapointValue, timestamp]);\n  }\n\n  const endTimestamp = options.end / 1e6;\n  for (let t = baseTimestampMs; t <= endTimestamp; t += stepMs) {\n    datapoints.push([null, t]);\n  }\n\n  return datapoints;\n}\n\nexport function lokiResultsToTableModel(\n  lokiResults: Array<LokiMatrixResult | LokiVectorResult>,\n  resultCount: number,\n  refId: string,\n  meta: QueryResultMeta,\n  valueWithRefId?: boolean\n): TableModel {\n  if (!lokiResults || lokiResults.length === 0) {\n    return new TableModel();\n  }\n\n  // Collect all labels across all metrics\n  const metricLabels: Set<string> = new Set<string>(\n    lokiResults.reduce((acc, cur) => acc.concat(Object.keys(cur.metric)), [] as string[])\n  );\n\n  // Sort metric labels, create columns for them and record their index\n  const sortedLabels = [...metricLabels.values()].sort();\n  const table = new TableModel();\n  table.refId = refId;\n  table.meta = meta;\n  table.columns = [\n    { text: 'Time', type: FieldType.time },\n    ...sortedLabels.map((label) => ({ text: label, filterable: true, type: FieldType.string })),\n    { text: resultCount > 1 || valueWithRefId ? `Value #${refId}` : 'Value', type: FieldType.number },\n  ];\n\n  // Populate rows, set value to empty string when label not present.\n  lokiResults.forEach((series) => {\n    const newSeries: LokiMatrixResult = {\n      metric: series.metric,\n      values: (series as LokiVectorResult).value\n        ? [(series as LokiVectorResult).value]\n        : (series as LokiMatrixResult).values,\n    };\n\n    if (!newSeries.values) {\n      return;\n    }\n\n    if (!newSeries.metric) {\n      table.rows.concat(newSeries.values.map(([a, b]) => [a * 1000, parseFloat(b)]));\n    } else {\n      table.rows.push(\n        ...newSeries.values.map(([a, b]) => [\n          a * 1000,\n          ...sortedLabels.map((label) => newSeries.metric[label] || ''),\n          parseFloat(b),\n        ])\n      );\n    }\n  });\n\n  return table;\n}\n\nexport function createMetricLabel(labelData: { [key: string]: string }, options?: TransformerOptions) {\n  let label =\n    options === undefined || isEmpty(options.legendFormat)\n      ? getOriginalMetricName(labelData)\n      : renderTemplate(getTemplateSrv().replace(options.legendFormat ?? '', options.scopedVars), labelData);\n\n  if (!label && options) {\n    label = options.query;\n  }\n  return label;\n}\n\nfunction renderTemplate(aliasPattern: string, aliasData: { [key: string]: string }) {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_, g1) => (aliasData[g1] ? aliasData[g1] : g1));\n}\n\nfunction getOriginalMetricName(labelData: { [key: string]: string }) {\n  const metricName = labelData.__name__ || '';\n  delete labelData.__name__;\n  const labelPart = Object.entries(labelData)\n    .map((label) => `${label[0]}=\"${label[1]}\"`)\n    .join(',');\n  return `${metricName}{${labelPart}}`;\n}\n\nexport function decamelize(s: string): string {\n  return s.replace(/[A-Z]/g, (m) => ` ${m.toLowerCase()}`);\n}\n\n// Turn loki stats { metric: value } into meta stat { title: metric, value: value }\nfunction lokiStatsToMetaStat(stats: LokiStats | undefined): QueryResultMetaStat[] {\n  const result: QueryResultMetaStat[] = [];\n\n  if (!stats) {\n    return result;\n  }\n\n  for (const section in stats) {\n    const values = stats[section];\n    for (const label in values) {\n      const value = values[label];\n      let unit;\n      if (/time/i.test(label) && value) {\n        unit = 's';\n      } else if (/bytes.*persecond/i.test(label)) {\n        unit = 'Bps';\n      } else if (/bytes/i.test(label)) {\n        unit = 'decbytes';\n      }\n      const title = `${capitalize(section)}: ${decamelize(label)}`;\n      result.push({ displayName: title, value, unit });\n    }\n  }\n\n  return result;\n}\n\nexport function lokiStreamsToDataFrames(\n  response: LokiStreamResponse,\n  target: { refId: string; expr?: string },\n  limit: number,\n  config: LokiOptions,\n  reverse = false\n): DataFrame[] {\n  const data = limit > 0 ? response.data.result : [];\n  const stats: QueryResultMetaStat[] = lokiStatsToMetaStat(response.data.stats);\n  // Use custom mechanism to identify which stat we want to promote to label\n  const custom = {\n    lokiQueryStatKey: 'Summary: total bytes processed',\n  };\n\n  const meta: QueryResultMeta = {\n    searchWords: getHighlighterExpressionsFromQuery(formatQuery(target.expr)),\n    limit,\n    stats,\n    custom,\n    preferredVisualisationType: 'logs',\n  };\n\n  const series: DataFrame[] = data.map((stream) => {\n    const dataFrame = lokiStreamResultToDataFrame(stream, reverse, target.refId);\n    enhanceDataFrame(dataFrame, config);\n\n    if (meta.custom && dataFrame.fields.some((f) => f.labels && Object.keys(f.labels).some((l) => l === '__error__'))) {\n      meta.custom.error = 'Error when parsing some of the logs';\n    }\n\n    return {\n      ...dataFrame,\n      refId: target.refId,\n      meta,\n    };\n  });\n\n  if (stats.length && !data.length) {\n    return [\n      {\n        fields: [],\n        length: 0,\n        refId: target.refId,\n        meta,\n      },\n    ];\n  }\n\n  return series;\n}\n\n/**\n * Adds new fields and DataLinks to DataFrame based on DataSource instance config.\n */\nexport const enhanceDataFrame = (dataFrame: DataFrame, config: LokiOptions | null): void => {\n  if (!config) {\n    return;\n  }\n\n  const derivedFields = config.derivedFields ?? [];\n  if (!derivedFields.length) {\n    return;\n  }\n  const derivedFieldsGrouped = groupBy(derivedFields, 'name');\n\n  const newFields = Object.values(derivedFieldsGrouped).map(fieldFromDerivedFieldConfig);\n\n  const view = new DataFrameView(dataFrame);\n  view.forEach((row: { line: string }) => {\n    for (const field of newFields) {\n      const logMatch = row.line.match(derivedFieldsGrouped[field.name][0].matcherRegex);\n      field.values.add(logMatch && logMatch[1]);\n    }\n  });\n\n  dataFrame.fields = [...dataFrame.fields, ...newFields];\n};\n\n/**\n * Transform derivedField config into dataframe field with config that contains link.\n */\nfunction fieldFromDerivedFieldConfig(derivedFieldConfigs: DerivedFieldConfig[]): Field<any, ArrayVector> {\n  const dataSourceSrv = getDataSourceSrv();\n\n  const dataLinks = derivedFieldConfigs.reduce((acc, derivedFieldConfig) => {\n    // Having field.datasourceUid means it is an internal link.\n    if (derivedFieldConfig.datasourceUid) {\n      const dsSettings = dataSourceSrv.getInstanceSettings(derivedFieldConfig.datasourceUid);\n\n      acc.push({\n        // Will be filled out later\n        title: derivedFieldConfig.urlDisplayLabel || '',\n        url: '',\n        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object\n        internal: {\n          query: { query: derivedFieldConfig.url },\n          datasourceUid: derivedFieldConfig.datasourceUid,\n          datasourceName: dsSettings?.name ?? 'Data source not found',\n        },\n      });\n    } else if (derivedFieldConfig.url) {\n      acc.push({\n        // We do not know what title to give here so we count on presentation layer to create a title from metadata.\n        title: derivedFieldConfig.urlDisplayLabel || '',\n        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object\n        url: derivedFieldConfig.url,\n      });\n    }\n    return acc;\n  }, [] as DataLink[]);\n\n  return {\n    name: derivedFieldConfigs[0].name,\n    type: FieldType.string,\n    config: {\n      links: dataLinks,\n    },\n    // We are adding values later on\n    values: new ArrayVector<string>([]),\n  };\n}\n\nexport function rangeQueryResponseToTimeSeries(\n  response: LokiResponse,\n  query: LokiRangeQueryRequest,\n  target: LokiQuery,\n  responseListLength: number,\n  scopedVars: ScopedVars\n): TimeSeries[] {\n  /** Show results of Loki metric queries only in graph */\n  const meta: QueryResultMeta = {\n    preferredVisualisationType: 'graph',\n  };\n  const transformerOptions: TransformerOptions = {\n    format: target.format,\n    legendFormat: target.legendFormat ?? '',\n    start: query.start!,\n    end: query.end!,\n    step: query.step!,\n    query: query.query,\n    responseListLength,\n    refId: target.refId,\n    meta,\n    valueWithRefId: target.valueWithRefId,\n    scopedVars,\n  };\n\n  switch (response.data.resultType) {\n    case LokiResultType.Vector:\n      return response.data.result.map((vecResult) =>\n        lokiMatrixToTimeSeries({ metric: vecResult.metric, values: [vecResult.value] }, transformerOptions)\n      );\n    case LokiResultType.Matrix:\n      return response.data.result.map((matrixResult) => lokiMatrixToTimeSeries(matrixResult, transformerOptions));\n    default:\n      return [];\n  }\n}\n\nexport function processRangeQueryResponse(\n  response: LokiResponse,\n  target: LokiQuery,\n  query: LokiRangeQueryRequest,\n  responseListLength: number,\n  limit: number,\n  config: LokiOptions,\n  scopedVars: ScopedVars,\n  reverse = false\n) {\n  switch (response.data.resultType) {\n    case LokiResultType.Stream:\n      return of({\n        data: lokiStreamsToDataFrames(response as LokiStreamResponse, target, limit, config, reverse),\n        key: `${target.refId}_log`,\n      });\n\n    case LokiResultType.Vector:\n    case LokiResultType.Matrix:\n      return of({\n        data: rangeQueryResponseToTimeSeries(\n          response,\n          query,\n          {\n            ...target,\n            format: 'time_series',\n          },\n          responseListLength,\n          scopedVars\n        ),\n        key: target.refId,\n      });\n    default:\n      throw new Error(`Unknown result type \"${(response.data as any).resultType}\".`);\n  }\n}\n","import { __assign, __extends } from \"tslib\";\nimport { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { ReplaySubject } from '../../ReplaySubject';\nvar DEFAULT_WEBSOCKET_CONFIG = {\n    url: '',\n    deserializer: function (e) { return JSON.parse(e.data); },\n    serializer: function (value) { return JSON.stringify(value); },\n};\nvar WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';\nvar WebSocketSubject = (function (_super) {\n    __extends(WebSocketSubject, _super);\n    function WebSocketSubject(urlConfigOrSource, destination) {\n        var _this = _super.call(this) || this;\n        _this._socket = null;\n        if (urlConfigOrSource instanceof Observable) {\n            _this.destination = destination;\n            _this.source = urlConfigOrSource;\n        }\n        else {\n            var config = (_this._config = __assign({}, DEFAULT_WEBSOCKET_CONFIG));\n            _this._output = new Subject();\n            if (typeof urlConfigOrSource === 'string') {\n                config.url = urlConfigOrSource;\n            }\n            else {\n                for (var key in urlConfigOrSource) {\n                    if (urlConfigOrSource.hasOwnProperty(key)) {\n                        config[key] = urlConfigOrSource[key];\n                    }\n                }\n            }\n            if (!config.WebSocketCtor && WebSocket) {\n                config.WebSocketCtor = WebSocket;\n            }\n            else if (!config.WebSocketCtor) {\n                throw new Error('no WebSocket constructor can be found');\n            }\n            _this.destination = new ReplaySubject();\n        }\n        return _this;\n    }\n    WebSocketSubject.prototype.lift = function (operator) {\n        var sock = new WebSocketSubject(this._config, this.destination);\n        sock.operator = operator;\n        sock.source = this;\n        return sock;\n    };\n    WebSocketSubject.prototype._resetState = function () {\n        this._socket = null;\n        if (!this.source) {\n            this.destination = new ReplaySubject();\n        }\n        this._output = new Subject();\n    };\n    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n        var self = this;\n        return new Observable(function (observer) {\n            try {\n                self.next(subMsg());\n            }\n            catch (err) {\n                observer.error(err);\n            }\n            var subscription = self.subscribe(function (x) {\n                try {\n                    if (messageFilter(x)) {\n                        observer.next(x);\n                    }\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });\n            return function () {\n                try {\n                    self.next(unsubMsg());\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n                subscription.unsubscribe();\n            };\n        });\n    };\n    WebSocketSubject.prototype._connectSocket = function () {\n        var _this = this;\n        var _a = this._config, WebSocketCtor = _a.WebSocketCtor, protocol = _a.protocol, url = _a.url, binaryType = _a.binaryType;\n        var observer = this._output;\n        var socket = null;\n        try {\n            socket = protocol ? new WebSocketCtor(url, protocol) : new WebSocketCtor(url);\n            this._socket = socket;\n            if (binaryType) {\n                this._socket.binaryType = binaryType;\n            }\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n        var subscription = new Subscription(function () {\n            _this._socket = null;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n            }\n        });\n        socket.onopen = function (evt) {\n            var _socket = _this._socket;\n            if (!_socket) {\n                socket.close();\n                _this._resetState();\n                return;\n            }\n            var openObserver = _this._config.openObserver;\n            if (openObserver) {\n                openObserver.next(evt);\n            }\n            var queue = _this.destination;\n            _this.destination = Subscriber.create(function (x) {\n                if (socket.readyState === 1) {\n                    try {\n                        var serializer = _this._config.serializer;\n                        socket.send(serializer(x));\n                    }\n                    catch (e) {\n                        _this.destination.error(e);\n                    }\n                }\n            }, function (err) {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                if (err && err.code) {\n                    socket.close(err.code, err.reason);\n                }\n                else {\n                    observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));\n                }\n                _this._resetState();\n            }, function () {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                socket.close();\n                _this._resetState();\n            });\n            if (queue && queue instanceof ReplaySubject) {\n                subscription.add(queue.subscribe(_this.destination));\n            }\n        };\n        socket.onerror = function (e) {\n            _this._resetState();\n            observer.error(e);\n        };\n        socket.onclose = function (e) {\n            _this._resetState();\n            var closeObserver = _this._config.closeObserver;\n            if (closeObserver) {\n                closeObserver.next(e);\n            }\n            if (e.wasClean) {\n                observer.complete();\n            }\n            else {\n                observer.error(e);\n            }\n        };\n        socket.onmessage = function (e) {\n            try {\n                var deserializer = _this._config.deserializer;\n                observer.next(deserializer(e));\n            }\n            catch (err) {\n                observer.error(err);\n            }\n        };\n    };\n    WebSocketSubject.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var source = this.source;\n        if (source) {\n            return source.subscribe(subscriber);\n        }\n        if (!this._socket) {\n            this._connectSocket();\n        }\n        this._output.subscribe(subscriber);\n        subscriber.add(function () {\n            var _socket = _this._socket;\n            if (_this._output.observers.length === 0) {\n                if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {\n                    _socket.close();\n                }\n                _this._resetState();\n            }\n        });\n        return subscriber;\n    };\n    WebSocketSubject.prototype.unsubscribe = function () {\n        var _socket = this._socket;\n        if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {\n            _socket.close();\n        }\n        this._resetState();\n        _super.prototype.unsubscribe.call(this);\n    };\n    return WebSocketSubject;\n}(AnonymousSubject));\nexport { WebSocketSubject };\n//# sourceMappingURL=WebSocketSubject.js.map","import { DataFrame, FieldType, parseLabels, KeyValue, CircularDataFrame } from '@grafana/data';\nimport { Observable, throwError, timer } from 'rxjs';\nimport { webSocket } from 'rxjs/webSocket';\nimport { LokiTailResponse } from './types';\nimport { finalize, map, retryWhen, mergeMap } from 'rxjs/operators';\nimport { appendResponseToBufferedData } from './result_transformer';\n\n/**\n * Maps directly to a query in the UI (refId is key)\n */\nexport interface LokiLiveTarget {\n  query: string;\n  url: string;\n  refId: string;\n  size: number;\n}\n\n/**\n * Cache of websocket streams that can be returned as observable. In case there already is a stream for particular\n * target it is returned and on subscription returns the latest dataFrame.\n */\nexport class LiveStreams {\n  private streams: KeyValue<Observable<DataFrame[]>> = {};\n\n  getStream(target: LokiLiveTarget, retryInterval = 5000): Observable<DataFrame[]> {\n    let stream = this.streams[target.url];\n\n    if (stream) {\n      return stream;\n    }\n\n    const data = new CircularDataFrame({ capacity: target.size });\n    data.addField({ name: 'ts', type: FieldType.time, config: { displayName: 'Time' } });\n    data.addField({ name: 'tsNs', type: FieldType.time, config: { displayName: 'Time ns' } });\n    data.addField({ name: 'line', type: FieldType.string }).labels = parseLabels(target.query);\n    data.addField({ name: 'labels', type: FieldType.other }); // The labels for each line\n    data.addField({ name: 'id', type: FieldType.string });\n    data.meta = { ...data.meta, preferredVisualisationType: 'logs' };\n    data.refId = target.refId;\n\n    stream = webSocket<LokiTailResponse>(target.url).pipe(\n      map((response: LokiTailResponse) => {\n        appendResponseToBufferedData(response, data);\n        return [data];\n      }),\n      retryWhen((attempts: Observable<any>) =>\n        attempts.pipe(\n          mergeMap((error, i) => {\n            const retryAttempt = i + 1;\n            // Code 1006 is used to indicate that a connection was closed abnormally.\n            // Added hard limit of 30 on number of retries.\n            // If connection was closed abnormally, and we wish to retry, otherwise throw error.\n            if (error.code === 1006 && retryAttempt < 30) {\n              if (retryAttempt > 10) {\n                // If more than 10 times retried, consol.warn, but keep reconnecting\n                console.warn(\n                  `Websocket connection is being disrupted. We keep reconnecting but consider starting new live tailing again. Error: ${error.reason}`\n                );\n              }\n              // Retry every 5s\n              return timer(retryInterval);\n            }\n            return throwError(error);\n          })\n        )\n      ),\n      finalize(() => {\n        delete this.streams[target.url];\n      })\n    );\n    this.streams[target.url] = stream;\n\n    return stream;\n  }\n}\n","import { WebSocketSubject } from './WebSocketSubject';\nexport function webSocket(urlConfigOrSource) {\n    return new WebSocketSubject(urlConfigOrSource);\n}\n//# sourceMappingURL=webSocket.js.map","import { default as GraphiteQueryModel } from '../../graphite/graphite_query';\nimport { map } from 'lodash';\nimport { LokiQuery } from '../types';\nimport { GraphiteDatasource } from '../../graphite/datasource';\nimport { getTemplateSrv } from '../../../../features/templating/template_srv';\nimport { GraphiteMetricLokiMatcher, GraphiteQuery, GraphiteToLokiQueryImportConfiguration } from '../../graphite/types';\n\nconst GRAPHITE_TO_LOKI_OPERATOR = {\n  '=': '=',\n  '!=': '!=',\n  '=~': '=~',\n  '!=~': '!~',\n};\n\n/**\n * Converts Graphite glob-like pattern to a regular expression\n */\nfunction convertGlobToRegEx(text: string): string {\n  if (text.includes('*') || text.includes('{')) {\n    return '^' + text.replace(/\\*/g, '.*').replace(/\\{/g, '(').replace(/}/g, ')').replace(/,/g, '|');\n  } else {\n    return text;\n  }\n}\n\nexport default function fromGraphiteQueries(\n  graphiteQueries: GraphiteQuery[],\n  graphiteDataSource: GraphiteDatasource\n): LokiQuery[] {\n  return graphiteQueries.map((query) => {\n    const model: GraphiteQueryModel = new GraphiteQueryModel(\n      graphiteDataSource,\n      {\n        ...query,\n        target: query.target || '',\n        textEditor: false,\n      },\n      getTemplateSrv()\n    );\n    model.parseTarget();\n\n    return {\n      refId: query.refId,\n      expr: fromGraphite(model, graphiteDataSource.getImportQueryConfiguration().loki),\n    };\n  });\n}\n\nfunction fromGraphite(graphiteQuery: GraphiteQueryModel, config: GraphiteToLokiQueryImportConfiguration): string {\n  let matchingFound = false;\n  let labels: any = {};\n\n  if (graphiteQuery.seriesByTagUsed) {\n    matchingFound = true;\n    graphiteQuery.tags.forEach((tag) => {\n      labels[tag.key] = {\n        value: tag.value,\n        operator: GRAPHITE_TO_LOKI_OPERATOR[tag.operator],\n      };\n    });\n  } else {\n    const targetNodes = graphiteQuery.segments.map((segment) => segment.value);\n    let mappings = config.mappings.filter((mapping) => mapping.matchers.length <= targetNodes.length);\n\n    for (let mapping of mappings) {\n      const matchers = mapping.matchers.concat();\n\n      matchingFound = matchers.every((matcher: GraphiteMetricLokiMatcher, index: number) => {\n        if (matcher.labelName) {\n          let value = (targetNodes[index] as string)!;\n\n          if (value === '*') {\n            return true;\n          }\n\n          const converted = convertGlobToRegEx(value);\n          labels[matcher.labelName] = {\n            value: converted,\n            operator: converted !== value ? '=~' : '=',\n          };\n\n          return true;\n        }\n        return targetNodes[index] === matcher.value || matcher.value === '*';\n      });\n    }\n  }\n\n  let pairs = map(labels, (value, key) => `${key}${value.operator}\"${value.value}\"`);\n  if (matchingFound && pairs.length) {\n    return `{${pairs.join(', ')}}`;\n  } else {\n    return '';\n  }\n}\n","// Libraries\nimport { chain, difference } from 'lodash';\nimport LRU from 'lru-cache';\n\n// Services & Utils\nimport {\n  parseSelector,\n  labelRegexp,\n  selectorRegexp,\n  processLabels,\n} from 'app/plugins/datasource/prometheus/language_utils';\nimport syntax, { FUNCTIONS, PIPE_PARSERS, PIPE_OPERATORS } from './syntax';\n\n// Types\nimport { LokiQuery } from './types';\nimport { dateTime, AbsoluteTimeRange, LanguageProvider, HistoryItem, DataQuery, DataSourceApi } from '@grafana/data';\nimport { PromQuery } from '../prometheus/types';\nimport { GraphiteQuery } from '../graphite/types';\n\nimport LokiDatasource from './datasource';\nimport { CompletionItem, TypeaheadInput, TypeaheadOutput, CompletionItemGroup } from '@grafana/ui';\nimport { Grammar } from 'prismjs';\nimport fromGraphite from './importing/fromGraphite';\nimport { GraphiteDatasource } from '../graphite/datasource';\n\nconst DEFAULT_KEYS = ['job', 'namespace'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 10;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\nconst NS_IN_MS = 1000000;\n\n// When changing RATE_RANGES, check if Prometheus/PromQL ranges should be changed too\n// @see public/app/plugins/datasource/prometheus/promql.ts\nconst RATE_RANGES: CompletionItem[] = [\n  { label: '$__interval', sortValue: '$__interval' },\n  { label: '$__range', sortValue: '$__range' },\n  { label: '1m', sortValue: '00:01:00' },\n  { label: '5m', sortValue: '00:05:00' },\n  { label: '10m', sortValue: '00:10:00' },\n  { label: '30m', sortValue: '00:30:00' },\n  { label: '1h', sortValue: '01:00:00' },\n  { label: '1d', sortValue: '24:00:00' },\n];\n\nexport const LABEL_REFRESH_INTERVAL = 1000 * 30; // 30sec\n\nconst wrapLabel = (label: string) => ({ label, filterText: `\\\"${label}\\\"` });\n\nexport type LokiHistoryItem = HistoryItem<LokiQuery>;\n\ntype TypeaheadContext = {\n  history?: LokiHistoryItem[];\n  absoluteRange?: AbsoluteTimeRange;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: LokiHistoryItem[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter((h) => h.ts > cutoffTs && h.query.expr === item.label);\n  let hint = `Queried ${historyForItem.length} times in the last 24h.`;\n  const recent = historyForItem[0];\n\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nexport default class LokiLanguageProvider extends LanguageProvider {\n  labelKeys: string[];\n  labelFetchTs: number;\n  started = false;\n  datasource: LokiDatasource;\n  lookupsDisabled = false; // Dynamically set to true for big/slow instances\n\n  /**\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\n   *  10 as a max size is totally arbitrary right now.\n   */\n  private seriesCache = new LRU<string, Record<string, string[]>>(10);\n  private labelsCache = new LRU<string, string[]>(10);\n\n  constructor(datasource: LokiDatasource, initialValues?: any) {\n    super();\n\n    this.datasource = datasource;\n    this.labelKeys = [];\n    this.labelFetchTs = 0;\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars\n  cleanText = (s: string) => s.replace(/[{}[\\]=\"(),!~+\\-*/^%\\|]/g, '').trim();\n\n  getSyntax(): Grammar {\n    return syntax;\n  }\n\n  request = async (url: string, params?: any): Promise<any> => {\n    try {\n      return await this.datasource.metadataRequest(url, params);\n    } catch (error) {\n      console.error(error);\n    }\n\n    return undefined;\n  };\n\n  /**\n   * Initialise the language provider by fetching set of labels. Without this initialisation the provider would return\n   * just a set of hardcoded default labels on provideCompletionItems or a recent queries from history.\n   */\n  start = () => {\n    if (!this.startTask) {\n      this.startTask = this.fetchLabels().then(() => {\n        this.started = true;\n        return [];\n      });\n    }\n\n    return this.startTask;\n  };\n\n  getLabelKeys(): string[] {\n    return this.labelKeys;\n  }\n\n  /**\n   * Return suggestions based on input that can be then plugged into a typeahead dropdown.\n   * Keep this DOM-free for testing\n   * @param input\n   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems\n   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems\n   * @param context.history Optional used only in getEmptyCompletionItems\n   */\n  async provideCompletionItems(input: TypeaheadInput, context?: TypeaheadContext): Promise<TypeaheadOutput> {\n    const { wrapperClasses, value, prefix, text } = input;\n    const emptyResult: TypeaheadOutput = { suggestions: [] };\n\n    if (!value) {\n      return emptyResult;\n    }\n\n    // Local text properties\n    const empty = value?.document.text.length === 0;\n    const selectedLines = value.document.getTextsAtRange(value.selection);\n    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\n\n    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null;\n\n    // Syntax spans have 3 classes by default. More indicate a recognized token\n    const tokenRecognized = wrapperClasses.length > 3;\n\n    // Non-empty prefix, but not inside known token\n    const prefixUnrecognized = prefix && !tokenRecognized;\n\n    // Prevent suggestions in `function(|suffix)`\n    const noSuffix = !nextCharacter || nextCharacter === ')';\n\n    // Prefix is safe if it does not immediately follow a complete expression and has no text after it\n    const safePrefix = prefix && !text.match(/^['\"~=\\]})\\s]+$/) && noSuffix;\n\n    // About to type next operand if preceded by binary operator\n    const operatorsPattern = /[+\\-*/^%]/;\n    const isNextOperand = text.match(operatorsPattern);\n\n    // Determine candidates by CSS context\n    if (wrapperClasses.includes('context-range')) {\n      // Suggestions for metric[|]\n      return this.getRangeCompletionItems();\n    } else if (wrapperClasses.includes('context-labels')) {\n      // Suggestions for {|} and {foo=|}\n      return await this.getLabelCompletionItems(input);\n    } else if (wrapperClasses.includes('context-pipe')) {\n      return this.getPipeCompletionItem();\n    } else if (empty) {\n      // Suggestions for empty query field\n      return this.getEmptyCompletionItems(context);\n    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\n      // Show term suggestions in a couple of scenarios\n      return this.getBeginningCompletionItems(context);\n    } else if (prefixUnrecognized && safePrefix) {\n      // Show term suggestions in a couple of scenarios\n      return this.getTermCompletionItems();\n    }\n\n    return emptyResult;\n  }\n\n  getBeginningCompletionItems = (context?: TypeaheadContext): TypeaheadOutput => {\n    return {\n      suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions],\n    };\n  };\n\n  getEmptyCompletionItems(context?: TypeaheadContext): TypeaheadOutput {\n    const history = context?.history;\n    const suggestions = [];\n\n    if (history?.length) {\n      const historyItems = chain(history)\n        .map((h) => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map((item) => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: 'History',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  }\n\n  getTermCompletionItems = (): TypeaheadOutput => {\n    const suggestions = [];\n\n    suggestions.push({\n      prefixMatch: true,\n      label: 'Functions',\n      items: FUNCTIONS.map((suggestion) => ({ ...suggestion, kind: 'function' })),\n    });\n\n    return { suggestions };\n  };\n\n  getPipeCompletionItem = (): TypeaheadOutput => {\n    const suggestions = [];\n\n    suggestions.push({\n      label: 'Operators',\n      items: PIPE_OPERATORS.map((suggestion) => ({ ...suggestion, kind: 'operators' })),\n    });\n\n    suggestions.push({\n      label: 'Parsers',\n      items: PIPE_PARSERS.map((suggestion) => ({ ...suggestion, kind: 'parsers' })),\n    });\n\n    return { suggestions };\n  };\n\n  getRangeCompletionItems(): TypeaheadOutput {\n    return {\n      context: 'context-range',\n      suggestions: [\n        {\n          label: 'Range vector',\n          items: [...RATE_RANGES],\n        },\n      ],\n    };\n  }\n\n  async getLabelCompletionItems({ text, wrapperClasses, labelKey, value }: TypeaheadInput): Promise<TypeaheadOutput> {\n    let context = 'context-labels';\n    const suggestions: CompletionItemGroup[] = [];\n    if (!value) {\n      return { context, suggestions: [] };\n    }\n    const line = value.anchorBlock.getText();\n    const cursorOffset = value.selection.anchor.offset;\n    const isValueStart = text.match(/^(=|=~|!=|!~)/);\n\n    // Get normalized selector\n    let selector;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n      selector = parsedSelector.selector;\n    } catch {\n      selector = EMPTY_SELECTOR;\n    }\n\n    if (!labelKey && selector === EMPTY_SELECTOR) {\n      // start task gets all labels\n      await this.start();\n      const allLabels = this.getLabelKeys();\n      return { context, suggestions: [{ label: `Labels`, items: allLabels.map(wrapLabel) }] };\n    }\n\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    let labelValues;\n    // Query labels for selector\n    if (selector) {\n      if (selector === EMPTY_SELECTOR && labelKey) {\n        const labelValuesForKey = await this.getLabelValues(labelKey);\n        labelValues = { [labelKey]: labelValuesForKey };\n      } else {\n        labelValues = await this.getSeriesLabels(selector);\n      }\n    }\n\n    if (!labelValues) {\n      console.warn(`Server did not return any values for selector = ${selector}`);\n      return { context, suggestions };\n    }\n\n    if ((text && isValueStart) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && labelValues[labelKey]) {\n        context = 'context-label-values';\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"`,\n          // Filter to prevent previously selected values from being repeatedly suggested\n          items: labelValues[labelKey].map(wrapLabel).filter(({ filterText }) => filterText !== text),\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = labelValues ? Object.keys(labelValues) : DEFAULT_KEYS;\n      if (labelKeys) {\n        const possibleKeys = difference(labelKeys, existingKeys);\n        if (possibleKeys.length) {\n          const newItems = possibleKeys.map((key) => ({ label: key }));\n          const newSuggestion: CompletionItemGroup = { label: `Labels`, items: newItems };\n          suggestions.push(newSuggestion);\n        }\n      }\n    }\n\n    return { context, suggestions };\n  }\n\n  async importQueries(\n    queries: PromQuery[] | GraphiteQuery[] | DataQuery[],\n    originDataSource: DataSourceApi\n  ): Promise<LokiQuery[]> {\n    const datasourceType = originDataSource.meta.id;\n    if (datasourceType === 'prometheus') {\n      return Promise.all(\n        [...(queries as PromQuery[])].map(async (query) => {\n          const expr = await this.importPrometheusQuery(query.expr);\n          const { refId } = query;\n          return {\n            expr,\n            refId,\n            range: true,\n          };\n        })\n      );\n    }\n    if (datasourceType === 'graphite') {\n      return fromGraphite(queries, originDataSource as GraphiteDatasource);\n    }\n    // Return a cleaned LokiQuery\n    return queries.map((query) => ({\n      refId: query.refId,\n      expr: '',\n    }));\n  }\n\n  async importPrometheusQuery(query: string): Promise<string> {\n    if (!query) {\n      return '';\n    }\n\n    // Consider only first selector in query\n    const selectorMatch = query.match(selectorRegexp);\n    if (!selectorMatch) {\n      return '';\n    }\n\n    const selector = selectorMatch[0];\n    const labels: { [key: string]: { value: any; operator: any } } = {};\n    selector.replace(labelRegexp, (_, key, operator, value) => {\n      labels[key] = { value, operator };\n      return '';\n    });\n\n    // Keep only labels that exist on origin and target datasource\n    await this.start(); // fetches all existing label keys\n    const existingKeys = this.labelKeys;\n    let labelsToKeep: { [key: string]: { value: any; operator: any } } = {};\n    if (existingKeys && existingKeys.length) {\n      // Check for common labels\n      for (const key in labels) {\n        if (existingKeys && existingKeys.includes(key)) {\n          // Should we check for label value equality here?\n          labelsToKeep[key] = labels[key];\n        }\n      }\n    } else {\n      // Keep all labels by default\n      labelsToKeep = labels;\n    }\n\n    const labelKeys = Object.keys(labelsToKeep).sort();\n    const cleanSelector = labelKeys\n      .map((key) => `${key}${labelsToKeep[key].operator}${labelsToKeep[key].value}`)\n      .join(',');\n\n    return ['{', cleanSelector, '}'].join('');\n  }\n\n  async getSeriesLabels(selector: string) {\n    if (this.lookupsDisabled) {\n      return undefined;\n    }\n    try {\n      return await this.fetchSeriesLabels(selector);\n    } catch (error) {\n      // TODO: better error handling\n      console.error(error);\n      return undefined;\n    }\n  }\n\n  /**\n   * Fetches all label keys\n   */\n  async fetchLabels(): Promise<string[]> {\n    const url = '/loki/api/v1/label';\n    const timeRange = this.datasource.getTimeRangeParams();\n    this.labelFetchTs = Date.now().valueOf();\n\n    const res = await this.request(url, timeRange);\n    if (Array.isArray(res)) {\n      const labels = res\n        .slice()\n        .sort()\n        .filter((label) => label !== '__name__');\n      this.labelKeys = labels;\n    }\n\n    return [];\n  }\n\n  async refreshLogLabels(forceRefresh?: boolean) {\n    if ((this.labelKeys && Date.now().valueOf() - this.labelFetchTs > LABEL_REFRESH_INTERVAL) || forceRefresh) {\n      await this.fetchLabels();\n    }\n  }\n\n  /**\n   * Fetch labels for a selector. This is cached by it's args but also by the global timeRange currently selected as\n   * they can change over requested time.\n   * @param name\n   */\n  fetchSeriesLabels = async (match: string): Promise<Record<string, string[]>> => {\n    const url = '/loki/api/v1/series';\n    const { start, end } = this.datasource.getTimeRangeParams();\n\n    const cacheKey = this.generateCacheKey(url, start, end, match);\n    let value = this.seriesCache.get(cacheKey);\n    if (!value) {\n      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n      this.seriesCache.set(cacheKey, {});\n      const params = { 'match[]': match, start, end };\n      const data = await this.request(url, params);\n      const { values } = processLabels(data);\n      value = values;\n      this.seriesCache.set(cacheKey, value);\n    }\n    return value;\n  };\n\n  /**\n   * Fetch series for a selector. Use this for raw results. Use fetchSeriesLabels() to get labels.\n   * @param match\n   */\n  fetchSeries = async (match: string): Promise<Array<Record<string, string>>> => {\n    const url = '/loki/api/v1/series';\n    const { start, end } = this.datasource.getTimeRangeParams();\n    const params = { 'match[]': match, start, end };\n    return await this.request(url, params);\n  };\n\n  // Cache key is a bit different here. We round up to a minute the intervals.\n  // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\n  // millisecond while still actually getting all the keys for the correct interval. This still can create problems\n  // when user does not the newest values for a minute if already cached.\n  generateCacheKey(url: string, start: number, end: number, param: string): string {\n    return [url, this.roundTime(start), this.roundTime(end), param].join();\n  }\n\n  // Round nanos epoch to nearest 5 minute interval\n  roundTime(nanos: number): number {\n    return nanos ? Math.floor(nanos / NS_IN_MS / 1000 / 60 / 5) : 0;\n  }\n\n  async getLabelValues(key: string): Promise<string[]> {\n    return await this.fetchLabelValues(key);\n  }\n\n  async fetchLabelValues(key: string): Promise<string[]> {\n    const url = `/loki/api/v1/label/${key}/values`;\n    const rangeParams = this.datasource.getTimeRangeParams();\n    const { start, end } = rangeParams;\n\n    const cacheKey = this.generateCacheKey(url, start, end, key);\n    const params = { start, end };\n\n    let labelValues = this.labelsCache.get(cacheKey);\n    if (!labelValues) {\n      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n      this.labelsCache.set(cacheKey, []);\n      const res = await this.request(url, params);\n      if (Array.isArray(res)) {\n        labelValues = res.slice().sort();\n        this.labelsCache.set(cacheKey, labelValues);\n      }\n    }\n\n    return labelValues ?? [];\n  }\n}\n","// Libraries\nimport { cloneDeep, isEmpty, map as lodashMap } from 'lodash';\nimport { lastValueFrom, merge, Observable, of, throwError } from 'rxjs';\nimport { catchError, map, switchMap } from 'rxjs/operators';\nimport Prism from 'prismjs';\n\n// Types\nimport {\n  AnnotationEvent,\n  AnnotationQueryRequest,\n  DataFrame,\n  DataFrameView,\n  DataQuery,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataSourceWithLogsContextSupport,\n  DataSourceWithLogsVolumeSupport,\n  dateMath,\n  DateTime,\n  FieldCache,\n  FieldType,\n  getLogLevelFromKey,\n  Labels,\n  LoadingState,\n  LogLevel,\n  LogRowModel,\n  QueryResultMeta,\n  ScopedVars,\n  TimeRange,\n} from '@grafana/data';\nimport { BackendSrvRequest, FetchError, getBackendSrv } from '@grafana/runtime';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport { addLabelToQuery } from 'app/plugins/datasource/prometheus/add_label_to_query';\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { convertToWebSocketUrl } from 'app/core/utils/explore';\nimport {\n  lokiResultsToTableModel,\n  lokiStreamResultToDataFrame,\n  lokiStreamsToDataFrames,\n  processRangeQueryResponse,\n} from './result_transformer';\nimport { addParsedLabelToQuery, queryHasPipeParser } from './query_utils';\n\nimport {\n  LokiOptions,\n  LokiQuery,\n  LokiRangeQueryRequest,\n  LokiResultType,\n  LokiStreamResponse,\n  LokiStreamResult,\n} from './types';\nimport { LiveStreams, LokiLiveTarget } from './live_streams';\nimport LanguageProvider from './language_provider';\nimport { serializeParams } from '../../../core/utils/fetch';\nimport { RowContextOptions } from '@grafana/ui/src/components/Logs/LogRowContextProvider';\nimport syntax from './syntax';\nimport { DEFAULT_RESOLUTION } from './components/LokiOptionFields';\nimport { queryLogsVolume } from 'app/core/logs_model';\nimport config from 'app/core/config';\n\nexport type RangeQueryOptions = DataQueryRequest<LokiQuery> | AnnotationQueryRequest<LokiQuery>;\nexport const DEFAULT_MAX_LINES = 1000;\nexport const LOKI_ENDPOINT = '/loki/api/v1';\nconst NS_IN_MS = 1000000;\n\n/**\n * Loki's logs volume query may be expensive as it requires counting all logs in the selected range. If such query\n * takes too much time it may need be made more specific to limit number of logs processed under the hood.\n */\nconst LOGS_VOLUME_TIMEOUT = 10000;\n\nconst RANGE_QUERY_ENDPOINT = `${LOKI_ENDPOINT}/query_range`;\nconst INSTANT_QUERY_ENDPOINT = `${LOKI_ENDPOINT}/query`;\n\nconst DEFAULT_QUERY_PARAMS: Partial<LokiRangeQueryRequest> = {\n  direction: 'BACKWARD',\n  limit: DEFAULT_MAX_LINES,\n  query: '',\n};\n\nexport class LokiDatasource\n  extends DataSourceApi<LokiQuery, LokiOptions>\n  implements DataSourceWithLogsContextSupport, DataSourceWithLogsVolumeSupport<LokiQuery> {\n  private streams = new LiveStreams();\n  languageProvider: LanguageProvider;\n  maxLines: number;\n\n  constructor(\n    private instanceSettings: DataSourceInstanceSettings<LokiOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv(),\n    private readonly timeSrv: TimeSrv = getTimeSrv()\n  ) {\n    super(instanceSettings);\n\n    this.languageProvider = new LanguageProvider(this);\n    const settingsData = instanceSettings.jsonData || {};\n    this.maxLines = parseInt(settingsData.maxLines ?? '0', 10) || DEFAULT_MAX_LINES;\n  }\n\n  _request(apiUrl: string, data?: any, options?: Partial<BackendSrvRequest>): Observable<Record<string, any>> {\n    const baseUrl = this.instanceSettings.url;\n    const params = data ? serializeParams(data) : '';\n    const url = `${baseUrl}${apiUrl}${params.length ? `?${params}` : ''}`;\n    if (this.instanceSettings.withCredentials || this.instanceSettings.basicAuth) {\n      options = { ...options, withCredentials: true };\n      if (this.instanceSettings.basicAuth) {\n        options.headers = { ...options.headers, Authorization: this.instanceSettings.basicAuth };\n      }\n    }\n    const req = {\n      ...options,\n      url,\n    };\n\n    return getBackendSrv().fetch<Record<string, any>>(req);\n  }\n\n  getLogsVolumeDataProvider(request: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> | undefined {\n    if (!config.featureToggles.fullRangeLogsVolume) {\n      return undefined;\n    }\n\n    const isLogsVolumeAvailable = request.targets.some((target) => target.expr && !isMetricsQuery(target.expr));\n    if (!isLogsVolumeAvailable) {\n      return undefined;\n    }\n\n    const logsVolumeRequest = cloneDeep(request);\n    logsVolumeRequest.targets = logsVolumeRequest.targets\n      .filter((target) => target.expr && !isMetricsQuery(target.expr))\n      .map((target) => {\n        return {\n          ...target,\n          instant: false,\n          volumeQuery: true,\n          expr: `sum by (level) (count_over_time(${target.expr}[$__interval]))`,\n        };\n      });\n\n    return queryLogsVolume(this, logsVolumeRequest, {\n      timeout: LOGS_VOLUME_TIMEOUT,\n      extractLevel,\n      range: request.range,\n      targets: request.targets,\n    });\n  }\n\n  query(options: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> {\n    const subQueries: Array<Observable<DataQueryResponse>> = [];\n    const scopedVars = {\n      ...options.scopedVars,\n      ...this.getRangeScopedVars(options.range),\n    };\n    const filteredTargets = options.targets\n      .filter((target) => target.expr && !target.hide)\n      .map((target) => {\n        const expr = this.addAdHocFilters(target.expr);\n        return {\n          ...target,\n          expr: this.templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr),\n        };\n      });\n\n    for (const target of filteredTargets) {\n      if (target.instant) {\n        subQueries.push(this.runInstantQuery(target, options, filteredTargets.length));\n      } else {\n        subQueries.push(this.runRangeQuery(target, options, filteredTargets.length));\n      }\n    }\n\n    // No valid targets, return the empty result to save a round trip.\n    if (isEmpty(subQueries)) {\n      return of({\n        data: [],\n        state: LoadingState.Done,\n      });\n    }\n\n    return merge(...subQueries);\n  }\n\n  runInstantQuery = (\n    target: LokiQuery,\n    options: DataQueryRequest<LokiQuery>,\n    responseListLength = 1\n  ): Observable<DataQueryResponse> => {\n    const timeNs = this.getTime(options.range.to, true);\n    const queryLimit = isMetricsQuery(target.expr) ? options.maxDataPoints : target.maxLines;\n    const query = {\n      query: target.expr,\n      time: `${timeNs + (1e9 - (timeNs % 1e9))}`,\n      limit: Math.min(queryLimit || Infinity, this.maxLines),\n    };\n\n    /** Used only for results of metrics instant queries */\n    const meta: QueryResultMeta = {\n      preferredVisualisationType: 'table',\n    };\n\n    return this._request(INSTANT_QUERY_ENDPOINT, query).pipe(\n      map((response) => {\n        if (response.data.data.resultType === LokiResultType.Stream) {\n          return {\n            data: response.data\n              ? lokiStreamsToDataFrames(\n                  response.data as LokiStreamResponse,\n                  target,\n                  query.limit,\n                  this.instanceSettings.jsonData\n                )\n              : [],\n            key: `${target.refId}_instant`,\n          };\n        }\n\n        return {\n          data: [lokiResultsToTableModel(response.data.data.result, responseListLength, target.refId, meta, true)],\n          key: `${target.refId}_instant`,\n        };\n      }),\n      catchError((err) => throwError(() => this.processError(err, target)))\n    );\n  };\n\n  createRangeQuery(target: LokiQuery, options: RangeQueryOptions, limit: number): LokiRangeQueryRequest {\n    const query = target.expr;\n    let range: { start?: number; end?: number; step?: number } = {};\n    if (options.range) {\n      const startNs = this.getTime(options.range.from, false);\n      const endNs = this.getTime(options.range.to, true);\n      const rangeMs = Math.ceil((endNs - startNs) / 1e6);\n\n      const resolution = target.resolution || (DEFAULT_RESOLUTION.value as number);\n\n      const adjustedInterval =\n        this.adjustInterval((options as DataQueryRequest<LokiQuery>).intervalMs || 1000, resolution, rangeMs) / 1000;\n      // We want to ceil to 3 decimal places\n      const step = Math.ceil(adjustedInterval * 1000) / 1000;\n\n      range = {\n        start: startNs,\n        end: endNs,\n        step,\n      };\n    }\n\n    return {\n      ...DEFAULT_QUERY_PARAMS,\n      ...range,\n      query,\n      limit,\n    };\n  }\n\n  /**\n   * Attempts to send a query to /loki/api/v1/query_range\n   */\n  runRangeQuery = (\n    target: LokiQuery,\n    options: RangeQueryOptions,\n    responseListLength = 1\n  ): Observable<DataQueryResponse> => {\n    // For metric query we use maxDataPoints from the request options which should be something like width of the\n    // visualisation in pixels. In case of logs request we either use lines limit defined in the query target or\n    // global limit defined for the data source which ever is lower.\n    let maxDataPoints = isMetricsQuery(target.expr)\n      ? // We fallback to maxLines here because maxDataPoints is defined as possibly undefined. Not sure that can\n        // actually happen both Dashboards and Explore should send some value here. If not maxLines does not make that\n        // much sense but nor any other arbitrary value.\n        (options as DataQueryRequest<LokiQuery>).maxDataPoints || this.maxLines\n      : // If user wants maxLines 0 we still fallback to data source limit. I think that makes sense as why would anyone\n        // want to do a query and not see any results?\n        target.maxLines || this.maxLines;\n\n    if ((options as DataQueryRequest<LokiQuery>).liveStreaming) {\n      return this.runLiveQuery(target, maxDataPoints);\n    }\n    const query = this.createRangeQuery(target, options, maxDataPoints);\n\n    const headers = target.volumeQuery ? { 'X-Query-Tags': 'Source=logvolhist' } : undefined;\n\n    return this._request(RANGE_QUERY_ENDPOINT, query, { headers }).pipe(\n      catchError((err) => throwError(() => this.processError(err, target))),\n      switchMap((response) =>\n        processRangeQueryResponse(\n          response.data,\n          target,\n          query,\n          responseListLength,\n          maxDataPoints,\n          this.instanceSettings.jsonData,\n          (options as DataQueryRequest<LokiQuery>).scopedVars,\n          (options as DataQueryRequest<LokiQuery>).reverse\n        )\n      )\n    );\n  };\n\n  createLiveTarget(target: LokiQuery, maxDataPoints: number): LokiLiveTarget {\n    const query = target.expr;\n    const baseUrl = this.instanceSettings.url;\n    const params = serializeParams({ query });\n\n    return {\n      query,\n      url: convertToWebSocketUrl(`${baseUrl}/loki/api/v1/tail?${params}`),\n      refId: target.refId,\n      size: maxDataPoints,\n    };\n  }\n\n  /**\n   * Runs live queries which in this case means creating a websocket and listening on it for new logs.\n   * This returns a bit different dataFrame than runQueries as it returns single dataframe even if there are multiple\n   * Loki streams, sets only common labels on dataframe.labels and has additional dataframe.fields.labels for unique\n   * labels per row.\n   */\n  runLiveQuery = (target: LokiQuery, maxDataPoints: number): Observable<DataQueryResponse> => {\n    const liveTarget = this.createLiveTarget(target, maxDataPoints);\n\n    return this.streams.getStream(liveTarget).pipe(\n      map((data) => ({\n        data: data || [],\n        key: `loki-${liveTarget.refId}`,\n        state: LoadingState.Streaming,\n      })),\n      catchError((err: any) => {\n        return throwError(() => `Live tailing was stopped due to following error: ${err.reason}`);\n      })\n    );\n  };\n\n  getRangeScopedVars(range: TimeRange = this.timeSrv.timeRange()) {\n    const msRange = range.to.diff(range.from);\n    const sRange = Math.round(msRange / 1000);\n    return {\n      __range_ms: { text: msRange, value: msRange },\n      __range_s: { text: sRange, value: sRange },\n      __range: { text: sRange + 's', value: sRange + 's' },\n    };\n  }\n\n  interpolateVariablesInQueries(queries: LokiQuery[], scopedVars: ScopedVars): LokiQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length) {\n      expandedQueries = queries.map((query) => ({\n        ...query,\n        datasource: this.getRef(),\n        expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),\n      }));\n    }\n\n    return expandedQueries;\n  }\n\n  getQueryDisplayText(query: LokiQuery) {\n    return query.expr;\n  }\n\n  getTimeRangeParams() {\n    const timeRange = this.timeSrv.timeRange();\n    return { start: timeRange.from.valueOf() * NS_IN_MS, end: timeRange.to.valueOf() * NS_IN_MS };\n  }\n\n  async importQueries(queries: DataQuery[], originDataSource: DataSourceApi): Promise<LokiQuery[]> {\n    return this.languageProvider.importQueries(queries, originDataSource);\n  }\n\n  async metadataRequest(url: string, params?: Record<string, string | number>) {\n    const res = await lastValueFrom(this._request(url, params, { hideFromInspector: true }));\n    return res.data.data || res.data.values || [];\n  }\n\n  async metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    const interpolated = this.templateSrv.replace(query, {}, this.interpolateQueryExpr);\n    return await this.processMetricFindQuery(interpolated);\n  }\n\n  async processMetricFindQuery(query: string) {\n    const labelNamesRegex = /^label_names\\(\\)\\s*$/;\n    const labelValuesRegex = /^label_values\\((?:(.+),\\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*$/;\n\n    const labelNames = query.match(labelNamesRegex);\n    if (labelNames) {\n      return await this.labelNamesQuery();\n    }\n\n    const labelValues = query.match(labelValuesRegex);\n    if (labelValues) {\n      // If we have query expr, use /series endpoint\n      if (labelValues[1]) {\n        return await this.labelValuesSeriesQuery(labelValues[1], labelValues[2]);\n      }\n      return await this.labelValuesQuery(labelValues[2]);\n    }\n\n    return Promise.resolve([]);\n  }\n\n  async labelNamesQuery() {\n    const url = `${LOKI_ENDPOINT}/label`;\n    const params = this.getTimeRangeParams();\n    const result = await this.metadataRequest(url, params);\n    return result.map((value: string) => ({ text: value }));\n  }\n\n  async labelValuesQuery(label: string) {\n    const params = this.getTimeRangeParams();\n    const url = `${LOKI_ENDPOINT}/label/${label}/values`;\n    const result = await this.metadataRequest(url, params);\n    return result.map((value: string) => ({ text: value }));\n  }\n\n  async labelValuesSeriesQuery(expr: string, label: string) {\n    const timeParams = this.getTimeRangeParams();\n    const params = {\n      ...timeParams,\n      'match[]': expr,\n    };\n    const url = `${LOKI_ENDPOINT}/series`;\n    const streams = new Set();\n    const result = await this.metadataRequest(url, params);\n    result.forEach((stream: { [key: string]: string }) => {\n      if (stream[label]) {\n        streams.add({ text: stream[label] });\n      }\n    });\n\n    return Array.from(streams);\n  }\n\n  // By implementing getTagKeys and getTagValues we add ad-hoc filtters functionality\n  async getTagKeys() {\n    return await this.labelNamesQuery();\n  }\n\n  async getTagValues(options: any = {}) {\n    return await this.labelValuesQuery(options.key);\n  }\n\n  interpolateQueryExpr(value: any, variable: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return lokiRegularEscape(value);\n    }\n\n    if (typeof value === 'string') {\n      return lokiSpecialRegexEscape(value);\n    }\n\n    const escapedValues = lodashMap(value, lokiSpecialRegexEscape);\n    return escapedValues.join('|');\n  }\n\n  modifyQuery(query: LokiQuery, action: any): LokiQuery {\n    let expression = query.expr ?? '';\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        expression = this.addLabelToQuery(expression, action.key, action.value, '=');\n        break;\n      }\n      case 'ADD_FILTER_OUT': {\n        expression = this.addLabelToQuery(expression, action.key, action.value, '!=');\n        break;\n      }\n      default:\n        break;\n    }\n    return { ...query, expr: expression };\n  }\n\n  getTime(date: string | DateTime, roundUp: boolean) {\n    if (typeof date === 'string') {\n      date = dateMath.parse(date, roundUp)!;\n    }\n\n    return Math.ceil(date.valueOf() * 1e6);\n  }\n\n  getLogRowContext = (row: LogRowModel, options?: RowContextOptions): Promise<{ data: DataFrame[] }> => {\n    const target = this.prepareLogRowContextQueryTarget(\n      row,\n      (options && options.limit) || 10,\n      (options && options.direction) || 'BACKWARD'\n    );\n\n    const reverse = options && options.direction === 'FORWARD';\n    return lastValueFrom(\n      this._request(RANGE_QUERY_ENDPOINT, target).pipe(\n        catchError((err) => {\n          const error: DataQueryError = {\n            message: 'Error during context query. Please check JS console logs.',\n            status: err.status,\n            statusText: err.statusText,\n          };\n          throw error;\n        }),\n        switchMap((res) =>\n          of({\n            data: res.data\n              ? res.data.data.result.map((stream: LokiStreamResult) => lokiStreamResultToDataFrame(stream, reverse))\n              : [],\n          })\n        )\n      )\n    );\n  };\n\n  prepareLogRowContextQueryTarget = (row: LogRowModel, limit: number, direction: 'BACKWARD' | 'FORWARD') => {\n    const labels = this.languageProvider.getLabelKeys();\n    const query = Object.keys(row.labels)\n      .map((label: string) => {\n        if (labels.includes(label)) {\n          // escape backslashes in label as users can't escape them by themselves\n          return `${label}=\"${row.labels[label].replace(/\\\\/g, '\\\\\\\\')}\"`;\n        }\n        return '';\n      })\n      // Filter empty strings\n      .filter((label) => !!label)\n      .join(',');\n\n    const contextTimeBuffer = 2 * 60 * 60 * 1000; // 2h buffer\n    const commonTargetOptions = {\n      limit,\n      query: `{${query}}`,\n      expr: `{${query}}`,\n      direction,\n    };\n\n    const fieldCache = new FieldCache(row.dataFrame);\n    const nsField = fieldCache.getFieldByName('tsNs')!;\n    const nsTimestamp = nsField.values.get(row.rowIndex);\n\n    if (direction === 'BACKWARD') {\n      return {\n        ...commonTargetOptions,\n        // convert to ns, we loose some precision here but it is not that important at the far points of the context\n        start: row.timeEpochMs - contextTimeBuffer + '000000',\n        end: nsTimestamp,\n        direction,\n      };\n    } else {\n      return {\n        ...commonTargetOptions,\n        // start param in Loki API is inclusive so we'll have to filter out the row that this request is based from\n        // and any other that were logged in the same ns but before the row. Right now these rows will be lost\n        // because the are before but came it he response that should return only rows after.\n        start: nsTimestamp,\n        // convert to ns, we loose some precision here but it is not that important at the far points of the context\n        end: row.timeEpochMs + contextTimeBuffer + '000000',\n      };\n    }\n  };\n\n  testDatasource() {\n    // Consider only last 10 minutes otherwise request takes too long\n    const startMs = Date.now() - 10 * 60 * 1000;\n    const start = `${startMs}000000`; // API expects nanoseconds\n    return lastValueFrom(\n      this._request(`${LOKI_ENDPOINT}/label`, { start }).pipe(\n        map((res) => {\n          const values: any[] = res?.data?.data || res?.data?.values || [];\n          const testResult =\n            values.length > 0\n              ? { status: 'success', message: 'Data source connected and labels found.' }\n              : {\n                  status: 'error',\n                  message:\n                    'Data source connected, but no labels received. Verify that Loki and Promtail is configured properly.',\n                };\n          return testResult;\n        }),\n        catchError((err: any) => {\n          let message = 'Loki: ';\n          if (err.statusText) {\n            message += err.statusText;\n          } else {\n            message += 'Cannot connect to Loki';\n          }\n\n          if (err.status) {\n            message += `. ${err.status}`;\n          }\n\n          if (err.data && err.data.message) {\n            message += `. ${err.data.message}`;\n          } else if (err.data) {\n            message += `. ${err.data}`;\n          }\n          return of({ status: 'error', message: message });\n        })\n      )\n    );\n  }\n\n  async annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    const {\n      expr,\n      maxLines,\n      instant,\n      stepInterval,\n      tagKeys = '',\n      titleFormat = '',\n      textFormat = '',\n    } = options.annotation;\n\n    if (!expr) {\n      return [];\n    }\n\n    const interpolatedExpr = this.templateSrv.replace(expr, {}, this.interpolateQueryExpr);\n    const query = {\n      refId: `annotation-${options.annotation.name}`,\n      expr: interpolatedExpr,\n      maxLines,\n      instant,\n      stepInterval,\n    };\n    const { data } = instant\n      ? await lastValueFrom(this.runInstantQuery(query, options as any))\n      : await lastValueFrom(this.runRangeQuery(query, options as any));\n\n    const annotations: AnnotationEvent[] = [];\n    const splitKeys: string[] = tagKeys.split(',').filter((v: string) => v !== '');\n\n    for (const frame of data) {\n      const labels: { [key: string]: string } = {};\n      for (const field of frame.fields) {\n        if (field.labels) {\n          for (const [key, value] of Object.entries(field.labels)) {\n            labels[key] = String(value).trim();\n          }\n        }\n      }\n\n      const tags: string[] = [\n        ...new Set(\n          Object.entries(labels).reduce((acc: string[], [key, val]) => {\n            if (val === '') {\n              return acc;\n            }\n            if (splitKeys.length && !splitKeys.includes(key)) {\n              return acc;\n            }\n            acc.push.apply(acc, [val]);\n            return acc;\n          }, [])\n        ),\n      ];\n\n      const view = new DataFrameView<{ ts: string; line: string }>(frame);\n\n      view.forEach((row) => {\n        annotations.push({\n          time: new Date(row.ts).valueOf(),\n          title: renderTemplate(titleFormat, labels),\n          text: renderTemplate(textFormat, labels) || row.line,\n          tags,\n        });\n      });\n    }\n\n    return annotations;\n  }\n\n  showContextToggle(row?: LogRowModel): boolean {\n    return (row && row.searchWords && row.searchWords.length > 0) === true;\n  }\n\n  processError(err: FetchError, target: LokiQuery) {\n    let error = cloneDeep(err);\n    if (err.data.message.includes('escape') && target.expr.includes('\\\\')) {\n      error.data.message = `Error: ${err.data.message}. Make sure that all special characters are escaped with \\\\. For more information on escaping of special characters visit LogQL documentation at https://grafana.com/docs/loki/latest/logql/.`;\n    }\n    return error;\n  }\n\n  adjustInterval(dynamicInterval: number, resolution: number, range: number) {\n    // Loki will drop queries that might return more than 11000 data points.\n    // Calibrate interval if it is too small.\n    let safeInterval = range / 11000;\n    if (safeInterval > 1) {\n      safeInterval = Math.ceil(safeInterval);\n    }\n\n    let adjustedInterval = Math.max(resolution * dynamicInterval, safeInterval);\n    return adjustedInterval;\n  }\n\n  addAdHocFilters(queryExpr: string) {\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    let expr = queryExpr;\n\n    expr = adhocFilters.reduce((acc: string, filter: { key?: any; operator?: any; value?: any }) => {\n      const { key, operator } = filter;\n      let { value } = filter;\n      if (operator === '=~' || operator === '!~') {\n        value = lokiRegularEscape(value);\n      }\n\n      return this.addLabelToQuery(acc, key, value, operator);\n    }, expr);\n\n    return expr;\n  }\n\n  addLabelToQuery(queryExpr: string, key: string, value: string | number, operator: string) {\n    if (queryHasPipeParser(queryExpr) && !isMetricsQuery(queryExpr)) {\n      // If query has parser, we treat all labels as parsed and use | key=\"value\" syntax\n      return addParsedLabelToQuery(queryExpr, key, value, operator);\n    } else {\n      return addLabelToQuery(queryExpr, key, value, operator, true);\n    }\n  }\n}\n\nexport function renderTemplate(aliasPattern: string, aliasData: { [key: string]: string }) {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_match, g1) => {\n    if (aliasData[g1]) {\n      return aliasData[g1];\n    }\n    return '';\n  });\n}\n\nexport function lokiRegularEscape(value: any) {\n  if (typeof value === 'string') {\n    return value.replace(/'/g, \"\\\\\\\\'\");\n  }\n  return value;\n}\n\nexport function lokiSpecialRegexEscape(value: any) {\n  if (typeof value === 'string') {\n    return lokiRegularEscape(value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]+?.()|]/g, '\\\\\\\\$&'));\n  }\n  return value;\n}\n\n/**\n * Checks if the query expression uses function and so should return a time series instead of logs.\n * Sometimes important to know that before we actually do the query.\n */\nexport function isMetricsQuery(query: string): boolean {\n  const tokens = Prism.tokenize(query, syntax);\n  return tokens.some((t) => {\n    // Not sure in which cases it can be string maybe if nothing matched which means it should not be a function\n    return typeof t !== 'string' && t.type === 'function';\n  });\n}\n\nfunction extractLevel(dataFrame: DataFrame): LogLevel {\n  let valueField;\n  try {\n    valueField = new FieldCache(dataFrame).getFirstFieldOfType(FieldType.number);\n  } catch {}\n  return valueField?.labels ? getLogLevelFromLabels(valueField.labels) : LogLevel.unknown;\n}\n\nfunction getLogLevelFromLabels(labels: Labels): LogLevel {\n  const labelNames = ['level', 'lvl', 'loglevel'];\n  let levelLabel;\n  for (let labelName of labelNames) {\n    if (labelName in labels) {\n      levelLabel = labelName;\n      break;\n    }\n  }\n  return levelLabel ? getLogLevelFromKey(labels[levelLabel]) : LogLevel.unknown;\n}\n\nexport default LokiDatasource;\n","import React, { PureComponent } from 'react';\nimport { shuffle } from 'lodash';\nimport { QueryEditorHelpProps } from '@grafana/data';\nimport LokiLanguageProvider from '../language_provider';\nimport { LokiQuery } from '../types';\n\nconst DEFAULT_EXAMPLES = ['{job=\"default/prometheus\"}'];\nconst PREFERRED_LABELS = ['job', 'app', 'k8s_app'];\nconst EXAMPLES_LIMIT = 5;\n\nconst LOGQL_EXAMPLES = [\n  {\n    title: 'Log pipeline',\n    expression: '{job=\"mysql\"} |= \"metrics\" | logfmt | duration > 10s',\n    label:\n      'This query targets the MySQL job, filters out logs that don’t contain the word \"metrics\" and parses each log line to extract more labels and filters with them.',\n  },\n  {\n    title: 'Count over time',\n    expression: 'count_over_time({job=\"mysql\"}[5m])',\n    label: 'This query counts all the log lines within the last five minutes for the MySQL job.',\n  },\n  {\n    title: 'Rate',\n    expression: 'rate(({job=\"mysql\"} |= \"error\" != \"timeout\")[10s])',\n    label:\n      'This query gets the per-second rate of all non-timeout errors within the last ten seconds for the MySQL job.',\n  },\n  {\n    title: 'Aggregate, count, and group',\n    expression: 'sum(count_over_time({job=\"mysql\"}[5m])) by (level)',\n    label: 'Get the count of logs during the last five minutes, grouping by level.',\n  },\n];\n\nexport default class LokiCheatSheet extends PureComponent<QueryEditorHelpProps<LokiQuery>, { userExamples: string[] }> {\n  declare userLabelTimer: NodeJS.Timeout;\n  state = {\n    userExamples: [],\n  };\n\n  componentDidMount() {\n    this.scheduleUserLabelChecking();\n  }\n\n  componentWillUnmount() {\n    clearTimeout(this.userLabelTimer);\n  }\n\n  scheduleUserLabelChecking() {\n    this.userLabelTimer = setTimeout(this.checkUserLabels, 1000);\n  }\n\n  checkUserLabels = async () => {\n    // Set example from user labels\n    const provider: LokiLanguageProvider = this.props.datasource?.languageProvider;\n    if (provider.started) {\n      const labels = provider.getLabelKeys() || [];\n      const preferredLabel = PREFERRED_LABELS.find((l) => labels.includes(l));\n      if (preferredLabel) {\n        const values = await provider.getLabelValues(preferredLabel);\n        const userExamples = shuffle(values)\n          .slice(0, EXAMPLES_LIMIT)\n          .map((value) => `{${preferredLabel}=\"${value}\"}`);\n        this.setState({ userExamples });\n      }\n    } else {\n      this.scheduleUserLabelChecking();\n    }\n  };\n\n  renderExpression(expr: string) {\n    const { onClickExample } = this.props;\n\n    return (\n      <div className=\"cheat-sheet-item__example\" key={expr} onClick={(e) => onClickExample({ refId: 'A', expr })}>\n        <code>{expr}</code>\n      </div>\n    );\n  }\n\n  render() {\n    const { userExamples } = this.state;\n    const hasUserExamples = userExamples.length > 0;\n\n    return (\n      <div>\n        <h2>Loki Cheat Sheet</h2>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">See your logs</div>\n          <div className=\"cheat-sheet-item__label\">\n            Start by selecting a log stream from the Log browser, or alternatively you can write a stream selector into\n            the query field.\n          </div>\n          {hasUserExamples ? (\n            <div>\n              <div className=\"cheat-sheet-item__label\">Here are some example streams from your logs:</div>\n              {userExamples.map((example) => this.renderExpression(example))}\n            </div>\n          ) : (\n            <div>\n              <div className=\"cheat-sheet-item__label\">Here is an example of a log stream:</div>\n              {this.renderExpression(DEFAULT_EXAMPLES[0])}\n            </div>\n          )}\n        </div>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Combine stream selectors</div>\n          {this.renderExpression('{app=\"cassandra\",namespace=\"prod\"}')}\n          <div className=\"cheat-sheet-item__label\">Returns all log lines from streams that have both labels.</div>\n        </div>\n\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Filtering for search terms.</div>\n          {this.renderExpression('{app=\"cassandra\"} |~ \"(duration|latency)s*(=|is|of)s*[d.]+\"')}\n          {this.renderExpression('{app=\"cassandra\"} |= \"exact match\"')}\n          {this.renderExpression('{app=\"cassandra\"} != \"do not match\"')}\n          <div className=\"cheat-sheet-item__label\">\n            <a href=\"https://grafana.com/docs/loki/latest/logql/#log-pipeline\" target=\"logql\">\n              LogQL\n            </a>{' '}\n            supports exact and regular expression filters.\n          </div>\n        </div>\n        {LOGQL_EXAMPLES.map((item) => (\n          <div className=\"cheat-sheet-item\" key={item.expression}>\n            <div className=\"cheat-sheet-item__title\">{item.title}</div>\n            {this.renderExpression(item.expression)}\n            <div className=\"cheat-sheet-item__label\">{item.label}</div>\n          </div>\n        ))}\n      </div>\n    );\n  }\n}\n","// Libraries\nimport React, { memo } from 'react';\n\n// Types\nimport { QueryEditorProps } from '@grafana/data';\nimport { LokiDatasource } from '../datasource';\nimport { LokiQuery, LokiOptions } from '../types';\nimport { LokiQueryField } from './LokiQueryField';\nimport { LokiOptionFields } from './LokiOptionFields';\n\ntype Props = QueryEditorProps<LokiDatasource, LokiQuery, LokiOptions>;\n\nexport function LokiExploreQueryEditor(props: Props) {\n  const { query, data, datasource, history, onChange, onRunQuery, range } = props;\n\n  return (\n    <LokiQueryField\n      datasource={datasource}\n      query={query}\n      onChange={onChange}\n      onBlur={() => {}}\n      onRunQuery={onRunQuery}\n      history={history}\n      data={data}\n      range={range}\n      ExtraFieldElement={\n        <LokiOptionFields\n          queryType={query.instant ? 'instant' : 'range'}\n          lineLimitValue={query?.maxLines?.toString() || ''}\n          resolution={query.resolution || 1}\n          query={query}\n          onRunQuery={onRunQuery}\n          onChange={onChange}\n        />\n      }\n    />\n  );\n}\n\nexport default memo(LokiExploreQueryEditor);\n","// Libraries\nimport React from 'react';\n\n// Types\nimport { InlineFormLabel } from '@grafana/ui';\nimport { LokiQueryField } from './LokiQueryField';\nimport { LokiOptionFields } from './LokiOptionFields';\nimport { LokiQueryEditorProps } from './types';\n\nexport function LokiQueryEditor(props: LokiQueryEditorProps) {\n  const { query, data, datasource, onChange, onRunQuery, range } = props;\n\n  const onLegendChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const nextQuery = { ...query, legendFormat: e.currentTarget.value };\n    onChange(nextQuery);\n  };\n\n  const legendField = (\n    <div className=\"gf-form-inline\">\n      <div className=\"gf-form\">\n        <InlineFormLabel\n          width={6}\n          tooltip=\"Controls the name of the time series, using name or pattern. For example\n        {{hostname}} will be replaced with label value for the label hostname. The legend only applies to metric queries.\"\n        >\n          Legend\n        </InlineFormLabel>\n        <input\n          type=\"text\"\n          className=\"gf-form-input\"\n          placeholder=\"legend format\"\n          value={query.legendFormat || ''}\n          onChange={onLegendChange}\n          onBlur={onRunQuery}\n        />\n      </div>\n    </div>\n  );\n\n  return (\n    <LokiQueryField\n      datasource={datasource}\n      query={query}\n      onChange={onChange}\n      onRunQuery={onRunQuery}\n      onBlur={onRunQuery}\n      history={[]}\n      data={data}\n      data-testid={testIds.editor}\n      range={range}\n      ExtraFieldElement={\n        <>\n          <LokiOptionFields\n            queryType={query.instant ? 'instant' : 'range'}\n            lineLimitValue={query?.maxLines?.toString() || ''}\n            resolution={query?.resolution || 1}\n            query={query}\n            onRunQuery={onRunQuery}\n            onChange={onChange}\n            runOnBlur={true}\n          />\n          {legendField}\n        </>\n      }\n    />\n  );\n}\n\nexport const testIds = {\n  editor: 'loki-editor',\n};\n","import React from 'react';\nimport { LokiQueryField } from './LokiQueryField';\nimport { LokiQueryEditorProps } from './types';\n\nexport function LokiQueryEditorForAlerting(props: LokiQueryEditorProps) {\n  const { query, data, datasource, onChange, onRunQuery } = props;\n\n  return (\n    <LokiQueryField\n      datasource={datasource}\n      query={query}\n      onChange={onChange}\n      onRunQuery={onRunQuery}\n      onBlur={onRunQuery}\n      history={[]}\n      data={data}\n      placeholder=\"Enter a Loki query\"\n      data-testid={testIds.editor}\n    />\n  );\n}\n\nexport const testIds = {\n  editor: 'loki-editor-cloud-alerting',\n};\n","import React, { memo } from 'react';\nimport { CoreApp } from '@grafana/data';\nimport { LokiQueryEditorProps } from './types';\nimport { LokiQueryEditor } from './LokiQueryEditor';\nimport { LokiQueryEditorForAlerting } from './LokiQueryEditorForAlerting';\n\nexport function LokiQueryEditorByApp(props: LokiQueryEditorProps) {\n  const { app } = props;\n\n  switch (app) {\n    case CoreApp.CloudAlerting:\n      return <LokiQueryEditorForAlerting {...props} />;\n    default:\n      return <LokiQueryEditor {...props} />;\n  }\n}\n\nexport default memo(LokiQueryEditorByApp);\n","import { LokiQuery } from './types';\n/**\n * Just a simple wrapper for a react component that is actually implementing the query editor.\n */\nexport class LokiAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n  declare annotation: any;\n\n  /** @ngInject */\n  constructor($scope: any) {\n    this.annotation = $scope.ctrl.annotation;\n    this.annotation.target = this.annotation.target || {};\n    this.onQueryChange = this.onQueryChange.bind(this);\n  }\n\n  onQueryChange(query: LokiQuery) {\n    this.annotation.expr = query.expr;\n    this.annotation.maxLines = query.maxLines;\n    this.annotation.instant = query.instant;\n  }\n}\n","import React from 'react';\nimport { LegacyForms } from '@grafana/ui';\nconst { FormField } = LegacyForms;\n\ntype Props = {\n  value: string;\n  onChange: (value: string) => void;\n};\n\nexport const MaxLinesField = (props: Props) => {\n  const { value, onChange } = props;\n  return (\n    <FormField\n      label=\"Maximum lines\"\n      labelWidth={11}\n      inputWidth={20}\n      inputEl={\n        <input\n          type=\"number\"\n          className=\"gf-form-input width-8 gf-form-input--has-help-icon\"\n          value={value}\n          onChange={(event) => onChange(event.currentTarget.value)}\n          spellCheck={false}\n          placeholder=\"1000\"\n        />\n      }\n      tooltip={\n        <>\n          Loki queries must contain a limit of the maximum number of lines returned (default: 1000). Increase this limit\n          to have a bigger result set for ad-hoc analysis. Decrease this limit if your browser becomes sluggish when\n          displaying the log results.\n        </>\n      }\n    />\n  );\n};\n","import React, { useEffect, useState } from 'react';\nimport { css } from '@emotion/css';\nimport { Button, DataLinkInput, stylesFactory, LegacyForms } from '@grafana/ui';\nimport { VariableSuggestion } from '@grafana/data';\nimport { DataSourcePicker } from '@grafana/runtime';\nimport { DerivedFieldConfig } from '../types';\nimport { usePrevious } from 'react-use';\n\nconst { Switch, FormField } = LegacyForms;\n\nconst getStyles = stylesFactory(() => ({\n  row: css`\n    display: flex;\n    align-items: baseline;\n  `,\n  nameField: css`\n    flex: 2;\n  `,\n  regexField: css`\n    flex: 3;\n  `,\n  urlField: css`\n    flex: 1;\n  `,\n  urlDisplayLabelField: css`\n    flex: 1;\n  `,\n}));\n\ntype Props = {\n  value: DerivedFieldConfig;\n  onChange: (value: DerivedFieldConfig) => void;\n  onDelete: () => void;\n  suggestions: VariableSuggestion[];\n  className?: string;\n};\nexport const DerivedField = (props: Props) => {\n  const { value, onChange, onDelete, suggestions, className } = props;\n  const styles = getStyles();\n  const [showInternalLink, setShowInternalLink] = useState(!!value.datasourceUid);\n  const previousUid = usePrevious(value.datasourceUid);\n\n  // Force internal link visibility change if uid changed outside of this component.\n  useEffect(() => {\n    if (!previousUid && value.datasourceUid && !showInternalLink) {\n      setShowInternalLink(true);\n    }\n    if (previousUid && !value.datasourceUid && showInternalLink) {\n      setShowInternalLink(false);\n    }\n  }, [previousUid, value.datasourceUid, showInternalLink]);\n\n  const handleChange = (field: keyof typeof value) => (event: React.ChangeEvent<HTMLInputElement>) => {\n    onChange({\n      ...value,\n      [field]: event.currentTarget.value,\n    });\n  };\n\n  return (\n    <div className={className}>\n      <div className={styles.row}>\n        <FormField\n          className={styles.nameField}\n          labelWidth={5}\n          // A bit of a hack to prevent using default value for the width from FormField\n          inputWidth={null}\n          label=\"Name\"\n          type=\"text\"\n          value={value.name}\n          onChange={handleChange('name')}\n        />\n        <FormField\n          className={styles.regexField}\n          inputWidth={null}\n          label=\"Regex\"\n          type=\"text\"\n          value={value.matcherRegex}\n          onChange={handleChange('matcherRegex')}\n          tooltip={\n            'Use to parse and capture some part of the log message. You can use the captured groups in the template.'\n          }\n        />\n        <Button\n          variant=\"destructive\"\n          title=\"Remove field\"\n          icon=\"times\"\n          onClick={(event) => {\n            event.preventDefault();\n            onDelete();\n          }}\n          className={css`\n            margin-left: 8px;\n          `}\n        />\n      </div>\n\n      <div className={styles.row}>\n        <FormField\n          label={showInternalLink ? 'Query' : 'URL'}\n          inputEl={\n            <DataLinkInput\n              placeholder={showInternalLink ? '${__value.raw}' : 'http://example.com/${__value.raw}'}\n              value={value.url || ''}\n              onChange={(newValue) =>\n                onChange({\n                  ...value,\n                  url: newValue,\n                })\n              }\n              suggestions={suggestions}\n            />\n          }\n          className={styles.urlField}\n        />\n        <FormField\n          className={styles.urlDisplayLabelField}\n          inputWidth={null}\n          label=\"URL Label\"\n          type=\"text\"\n          value={value.urlDisplayLabel}\n          onChange={handleChange('urlDisplayLabel')}\n          tooltip={'Use to override the button label when this derived field is found in a log.'}\n        />\n      </div>\n\n      <div className={styles.row}>\n        <Switch\n          label=\"Internal link\"\n          checked={showInternalLink}\n          onChange={() => {\n            if (showInternalLink) {\n              onChange({\n                ...value,\n                datasourceUid: undefined,\n              });\n            }\n            setShowInternalLink(!showInternalLink);\n          }}\n        />\n\n        {showInternalLink && (\n          <DataSourcePicker\n            tracing={true}\n            onChange={(ds) =>\n              onChange({\n                ...value,\n                datasourceUid: ds.uid,\n              })\n            }\n            current={value.datasourceUid}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n","import React, { useState } from 'react';\nimport { css } from '@emotion/css';\nimport cx from 'classnames';\nimport { LegacyForms } from '@grafana/ui';\nconst { FormField } = LegacyForms;\nimport { DerivedFieldConfig } from '../types';\nimport { ArrayVector, Field, FieldType, LinkModel } from '@grafana/data';\nimport { getFieldLinksForExplore } from '../../../../features/explore/utils/links';\n\ntype Props = {\n  derivedFields?: DerivedFieldConfig[];\n  className?: string;\n};\nexport const DebugSection = (props: Props) => {\n  const { derivedFields, className } = props;\n  const [debugText, setDebugText] = useState('');\n\n  let debugFields: DebugField[] = [];\n  if (debugText && derivedFields) {\n    debugFields = makeDebugFields(derivedFields, debugText);\n  }\n\n  return (\n    <div className={className}>\n      <FormField\n        labelWidth={12}\n        label={'Debug log message'}\n        inputEl={\n          <textarea\n            placeholder={'Paste an example log line here to test the regular expressions of your derived fields'}\n            className={cx(\n              'gf-form-input gf-form-textarea',\n              css`\n                width: 100%;\n              `\n            )}\n            value={debugText}\n            onChange={(event) => setDebugText(event.currentTarget.value)}\n          />\n        }\n      />\n      {!!debugFields.length && <DebugFields fields={debugFields} />}\n    </div>\n  );\n};\n\ntype DebugFieldItemProps = {\n  fields: DebugField[];\n};\nconst DebugFields = ({ fields }: DebugFieldItemProps) => {\n  return (\n    <table className={'filter-table'}>\n      <thead>\n        <tr>\n          <th>Name</th>\n          <th>Value</th>\n          <th>Url</th>\n        </tr>\n      </thead>\n      <tbody>\n        {fields.map((field) => {\n          let value: any = field.value;\n          if (field.error) {\n            value = field.error.message;\n          } else if (field.href) {\n            value = <a href={field.href}>{value}</a>;\n          }\n          return (\n            <tr key={`${field.name}=${field.value}`}>\n              <td>{field.name}</td>\n              <td>{value}</td>\n              <td>{field.href ? <a href={field.href}>{field.href}</a> : ''}</td>\n            </tr>\n          );\n        })}\n      </tbody>\n    </table>\n  );\n};\n\ntype DebugField = {\n  name: string;\n  error?: any;\n  value?: string;\n  href?: string;\n};\n\nfunction makeDebugFields(derivedFields: DerivedFieldConfig[], debugText: string): DebugField[] {\n  return derivedFields\n    .filter((field) => field.name && field.matcherRegex)\n    .map((field) => {\n      try {\n        const testMatch = debugText.match(field.matcherRegex);\n        const value = testMatch && testMatch[1];\n        let link: LinkModel<Field> | null = null;\n\n        if (field.url && value) {\n          link = getFieldLinksForExplore({\n            field: {\n              name: '',\n              type: FieldType.string,\n              values: new ArrayVector([value]),\n              config: {\n                links: [{ title: '', url: field.url }],\n              },\n            },\n            rowIndex: 0,\n            range: {} as any,\n          })[0];\n        }\n\n        return {\n          name: field.name,\n          value: value || '<no match>',\n          href: link && link.href,\n        } as DebugField;\n      } catch (error) {\n        return {\n          name: field.name,\n          error,\n        } as DebugField;\n      }\n    });\n}\n","import React, { useState } from 'react';\nimport { css } from '@emotion/css';\nimport { Button, useTheme2 } from '@grafana/ui';\nimport { GrafanaTheme2, VariableOrigin, DataLinkBuiltInVars } from '@grafana/data';\nimport { DerivedFieldConfig } from '../types';\nimport { DerivedField } from './DerivedField';\nimport { DebugSection } from './DebugSection';\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  infoText: css`\n    padding-bottom: ${theme.spacing(2)};\n    color: ${theme.colors.text.secondary};\n  `,\n  derivedField: css`\n    margin-bottom: ${theme.spacing(1)};\n  `,\n});\n\ntype Props = {\n  value?: DerivedFieldConfig[];\n  onChange: (value: DerivedFieldConfig[]) => void;\n};\n\nexport const DerivedFields = (props: Props) => {\n  const { value, onChange } = props;\n  const theme = useTheme2();\n  const styles = getStyles(theme);\n\n  const [showDebug, setShowDebug] = useState(false);\n\n  return (\n    <>\n      <h3 className=\"page-heading\">Derived fields</h3>\n\n      <div className={styles.infoText}>\n        Derived fields can be used to extract new fields from a log message and create a link from its value.\n      </div>\n\n      <div className=\"gf-form-group\">\n        {value &&\n          value.map((field, index) => {\n            return (\n              <DerivedField\n                className={styles.derivedField}\n                key={index}\n                value={field}\n                onChange={(newField) => {\n                  const newDerivedFields = [...value];\n                  newDerivedFields.splice(index, 1, newField);\n                  onChange(newDerivedFields);\n                }}\n                onDelete={() => {\n                  const newDerivedFields = [...value];\n                  newDerivedFields.splice(index, 1);\n                  onChange(newDerivedFields);\n                }}\n                suggestions={[\n                  {\n                    value: DataLinkBuiltInVars.valueRaw,\n                    label: 'Raw value',\n                    documentation: 'Exact string captured by the regular expression',\n                    origin: VariableOrigin.Value,\n                  },\n                ]}\n              />\n            );\n          })}\n        <div>\n          <Button\n            variant=\"secondary\"\n            className={css`\n              margin-right: 10px;\n            `}\n            icon=\"plus\"\n            onClick={(event) => {\n              event.preventDefault();\n              const newDerivedFields = [...(value || []), { name: '', matcherRegex: '' }];\n              onChange(newDerivedFields);\n            }}\n          >\n            Add\n          </Button>\n\n          {value && value.length > 0 && (\n            <Button variant=\"secondary\" type=\"button\" onClick={() => setShowDebug(!showDebug)}>\n              {showDebug ? 'Hide example log message' : 'Show example log message'}\n            </Button>\n          )}\n        </div>\n      </div>\n\n      {showDebug && (\n        <div className=\"gf-form-group\">\n          <DebugSection\n            className={css`\n              margin-bottom: 10px;\n            `}\n            derivedFields={value}\n          />\n        </div>\n      )}\n    </>\n  );\n};\n","import React from 'react';\nimport { DataSourcePluginOptionsEditorProps, DataSourceSettings } from '@grafana/data';\nimport { AlertingSettings, DataSourceHttpSettings } from '@grafana/ui';\nimport { LokiOptions } from '../types';\nimport { MaxLinesField } from './MaxLinesField';\nimport { DerivedFields } from './DerivedFields';\nimport { getAllAlertmanagerDataSources } from 'app/features/alerting/unified/utils/alertmanager';\n\nexport type Props = DataSourcePluginOptionsEditorProps<LokiOptions>;\n\nconst makeJsonUpdater = <T extends any>(field: keyof LokiOptions) => (\n  options: DataSourceSettings<LokiOptions>,\n  value: T\n): DataSourceSettings<LokiOptions> => {\n  return {\n    ...options,\n    jsonData: {\n      ...options.jsonData,\n      [field]: value,\n    },\n  };\n};\n\nconst setMaxLines = makeJsonUpdater('maxLines');\nconst setDerivedFields = makeJsonUpdater('derivedFields');\n\nexport const ConfigEditor = (props: Props) => {\n  const { options, onOptionsChange } = props;\n  const alertmanagers = getAllAlertmanagerDataSources();\n\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl={'http://localhost:3100'}\n        dataSourceConfig={options}\n        showAccessOptions={false}\n        onChange={onOptionsChange}\n      />\n\n      <AlertingSettings<LokiOptions>\n        alertmanagerDataSources={alertmanagers}\n        options={options}\n        onOptionsChange={onOptionsChange}\n      />\n\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <MaxLinesField\n              value={options.jsonData.maxLines || ''}\n              onChange={(value) => onOptionsChange(setMaxLines(options, value))}\n            />\n          </div>\n        </div>\n      </div>\n\n      <DerivedFields\n        value={options.jsonData.derivedFields}\n        onChange={(value) => onOptionsChange(setDerivedFields(options, value))}\n      />\n    </>\n  );\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport Datasource from './datasource';\n\nimport LokiCheatSheet from './components/LokiCheatSheet';\nimport LokiExploreQueryEditor from './components/LokiExploreQueryEditor';\nimport LokiQueryEditorByApp from './components/LokiQueryEditorByApp';\nimport { LokiAnnotationsQueryCtrl } from './LokiAnnotationsQueryCtrl';\nimport { ConfigEditor } from './configuration/ConfigEditor';\n\nexport const plugin = new DataSourcePlugin(Datasource)\n  .setQueryEditor(LokiQueryEditorByApp)\n  .setConfigEditor(ConfigEditor)\n  .setExploreQueryField(LokiExploreQueryEditor)\n  .setQueryEditorHelp(LokiCheatSheet)\n  .setAnnotationQueryCtrl(LokiAnnotationsQueryCtrl);\n"],"names":["uuid","validate","TypeError","v","arr","Uint8Array","parseInt","slice","f","s","x","y","z","ROTL","n","v5","name","version","hashfunc","generateUUID","value","namespace","buf","offset","str","unescape","encodeURIComponent","bytes","i","length","push","charCodeAt","stringToBytes","set","stringify","err","DNS","URL","v35","K","H","msg","Array","isArray","prototype","call","l","N","Math","ceil","M","_i","Uint32Array","j","pow","floor","_i2","W","t","_t","a","b","c","d","e","_t2","T","getHighlighterExpressionsFromQuery","input","expression","results","filterStart","search","filterOperator","substr","skip","filterEnd","filterTerm","trim","quotedTerm","match","backtickedTerm","term","unwrappedFilterTerm","replace","escapeRegExp","LokiResultType","lokiStreamResultToDataFrame","stream","reverse","refId","labels","labelsString","Object","entries","map","key","val","sort","join","times","ArrayVector","timesNs","lines","uids","usedUids","ts","line","values","add","Date","toISOString","createUid","dataFrame","fields","type","FieldType","config","displayName","mutableDataFrame","MutableDataFrame","constructDataFrame","id","uuidv5","newCount","lokiMatrixToTimeSeries","matrixResult","options","labelData","label","undefined","isEmpty","legendFormat","metricName","__name__","labelPart","getOriginalMetricName","aliasPattern","aliasData","aliasRegex","_","g1","renderTemplate","getTemplateSrv","scopedVars","query","createMetricLabel","metric","target","title","datapoints","lokiPointsToTimeseriesPoints","tags","meta","data","stepMs","step","baseTimestampMs","start","time","datapointValue","parseFloat","isNaN","timestamp","endTimestamp","end","lokiResultsToTableModel","lokiResults","resultCount","valueWithRefId","TableModel","sortedLabels","Set","reduce","acc","cur","concat","keys","table","columns","text","filterable","forEach","series","newSeries","rows","lokiStreamsToDataFrames","response","limit","result","stats","section","unit","test","capitalize","m","toLowerCase","lokiStatsToMetaStat","searchWords","selector","expr","custom","lokiQueryStatKey","preferredVisualisationType","enhanceDataFrame","some","error","derivedFields","derivedFieldsGrouped","groupBy","newFields","fieldFromDerivedFieldConfig","DataFrameView","row","field","logMatch","matcherRegex","derivedFieldConfigs","dataSourceSrv","getDataSourceSrv","dataLinks","derivedFieldConfig","datasourceUid","dsSettings","getInstanceSettings","urlDisplayLabel","url","internal","datasourceName","links","rangeQueryResponseToTimeSeries","responseListLength","transformerOptions","format","resultType","Vector","vecResult","Matrix","DEFAULT_WEBSOCKET_CONFIG","deserializer","JSON","parse","serializer","WebSocketSubject","_super","urlConfigOrSource","destination","_this","this","_socket","Observable","source","_config","_output","Subject","hasOwnProperty","WebSocketCtor","WebSocket","Error","ReplaySubject","lift","operator","sock","_resetState","multiplex","subMsg","unsubMsg","messageFilter","self","observer","next","subscription","subscribe","complete","unsubscribe","_connectSocket","_a","protocol","binaryType","socket","Subscription","readyState","close","onopen","evt","openObserver","queue","Subscriber","send","closingObserver","code","reason","onerror","onclose","closeObserver","wasClean","onmessage","_subscribe","subscriber","observers","LiveStreams","getStream","retryInterval","streams","CircularDataFrame","capacity","size","addField","parseLabels","pipe","baseLabels","tsField","tsNsField","lineField","labelsField","idField","unique","findUniqueLabels","allLabelsString","appendResponseToBufferedData","retryWhen","attempts","mergeMap","retryAttempt","console","warn","timer","throwError","finalize","GRAPHITE_TO_LOKI_OPERATOR","fromGraphite","graphiteQuery","matchingFound","seriesByTagUsed","tag","targetNodes","segments","segment","mappings","filter","mapping","matchers","every","matcher","index","labelName","converted","includes","pairs","DEFAULT_KEYS","EMPTY_SELECTOR","RATE_RANGES","sortValue","wrapLabel","filterText","LokiLanguageProvider","LanguageProvider","constructor","datasource","initialValues","super","LRU","async","params","metadataRequest","startTask","fetchLabels","then","started","context","suggestions","getEmptyCompletionItems","getTermCompletionItems","prefixMatch","items","FUNCTIONS","suggestion","kind","PIPE_OPERATORS","PIPE_PARSERS","getTimeRangeParams","cacheKey","generateCacheKey","seriesCache","get","request","processLabels","labelKeys","labelFetchTs","assign","getSyntax","syntax","getLabelKeys","wrapperClasses","prefix","emptyResult","empty","document","selectedLines","getTextsAtRange","selection","currentLine","first","getText","nextCharacter","anchor","tokenRecognized","prefixUnrecognized","noSuffix","safePrefix","isNextOperand","getRangeCompletionItems","getLabelCompletionItems","getPipeCompletionItem","getBeginningCompletionItems","history","historyItems","chain","h","uniq","take","item","cutoffTs","now","historyForItem","hint","recent","dateTime","fromNow","documentation","addHistoryMetadata","skipSort","labelKey","anchorBlock","cursorOffset","isValueStart","parsedSelector","parseSelector","existingKeys","labelValues","getLabelValues","getSeriesLabels","possibleKeys","difference","newSuggestion","queries","originDataSource","datasourceType","Promise","all","importPrometheusQuery","range","graphiteDataSource","model","GraphiteQueryModel","textEditor","parseTarget","getImportQueryConfiguration","loki","selectorMatch","selectorRegexp","labelRegexp","labelsToKeep","lookupsDisabled","fetchSeriesLabels","timeRange","valueOf","res","forceRefresh","param","roundTime","nanos","fetchLabelValues","rangeParams","labelsCache","NS_IN_MS","RANGE_QUERY_ENDPOINT","DEFAULT_QUERY_PARAMS","direction","LokiDatasource","DataSourceApi","instanceSettings","templateSrv","timeSrv","getTimeSrv","timeNs","getTime","to","queryLimit","isMetricsQuery","maxDataPoints","maxLines","min","Infinity","_request","Stream","jsonData","catchError","processError","liveStreaming","runLiveQuery","createRangeQuery","headers","volumeQuery","switchMap","of","processRangeQueryResponse","liveTarget","createLiveTarget","state","LoadingState","prepareLogRowContextQueryTarget","lastValueFrom","message","status","statusText","languageProvider","contextTimeBuffer","commonTargetOptions","nsTimestamp","FieldCache","getFieldByName","rowIndex","timeEpochMs","settingsData","apiUrl","baseUrl","serializeParams","withCredentials","basicAuth","Authorization","req","getBackendSrv","fetch","getLogsVolumeDataProvider","targets","logsVolumeRequest","cloneDeep","instant","queryLogsVolume","timeout","extractLevel","subQueries","getRangeScopedVars","filteredTargets","hide","addAdHocFilters","interpolateQueryExpr","runInstantQuery","runRangeQuery","merge","startNs","from","endNs","rangeMs","resolution","DEFAULT_RESOLUTION","adjustedInterval","adjustInterval","intervalMs","convertToWebSocketUrl","msRange","diff","sRange","round","__range_ms","__range_s","__range","interpolateVariablesInQueries","expandedQueries","getRef","getQueryDisplayText","importQueries","hideFromInspector","resolve","interpolated","processMetricFindQuery","labelNamesQuery","labelValuesSeriesQuery","labelValuesQuery","timeParams","variable","multi","includeAll","lokiRegularEscape","lokiSpecialRegexEscape","lodashMap","modifyQuery","action","addLabelToQuery","date","roundUp","dateMath","testDatasource","stepInterval","tagKeys","titleFormat","textFormat","annotation","interpolatedExpr","annotations","splitKeys","split","frame","String","apply","showContextToggle","dynamicInterval","safeInterval","max","queryExpr","getAdhocFilters","parsers","parser","RegExp","queryHasPipeParser","toString","addParsedLabelToQuery","_match","Prism","valueField","getFirstFieldOfType","labelNames","levelLabel","getLogLevelFromKey","LogLevel","getLogLevelFromLabels","DEFAULT_EXAMPLES","PREFERRED_LABELS","LOGQL_EXAMPLES","LokiCheatSheet","PureComponent","userExamples","provider","props","preferredLabel","find","shuffle","setState","scheduleUserLabelChecking","componentDidMount","componentWillUnmount","clearTimeout","userLabelTimer","setTimeout","checkUserLabels","renderExpression","onClickExample","className","onClick","render","hasUserExamples","example","href","LokiExploreQueryEditor","onChange","onRunQuery","LokiQueryField","onBlur","ExtraFieldElement","LokiOptionFields","queryType","lineLimitValue","memo","LokiQueryEditor","legendField","InlineFormLabel","width","tooltip","placeholder","nextQuery","currentTarget","testIds","editor","runOnBlur","LokiQueryEditorForAlerting","LokiQueryEditorByApp","app","CoreApp","LokiAnnotationsQueryCtrl","$scope","ctrl","onQueryChange","bind","FormField","LegacyForms","MaxLinesField","labelWidth","inputWidth","inputEl","event","spellCheck","Switch","getStyles","stylesFactory","css","nameField","regexField","urlField","urlDisplayLabelField","DerivedField","onDelete","styles","showInternalLink","setShowInternalLink","useState","previousUid","usePrevious","useEffect","handleChange","Button","variant","icon","preventDefault","DataLinkInput","newValue","checked","DataSourcePicker","tracing","ds","uid","current","DebugSection","debugText","setDebugText","debugFields","testMatch","link","getFieldLinksForExplore","makeDebugFields","cx","DebugFields","DerivedFields","theme","infoText","spacing","colors","secondary","derivedField","useTheme2","showDebug","setShowDebug","newField","newDerivedFields","splice","DataLinkBuiltInVars","origin","VariableOrigin","makeJsonUpdater","setMaxLines","setDerivedFields","plugin","DataSourcePlugin","Datasource","setQueryEditor","setConfigEditor","onOptionsChange","alertmanagers","getAllAlertmanagerDataSources","DataSourceHttpSettings","defaultUrl","dataSourceConfig","showAccessOptions","AlertingSettings","alertmanagerDataSources","setExploreQueryField","setQueryEditorHelp","setAnnotationQueryCtrl"],"sourceRoot":""}