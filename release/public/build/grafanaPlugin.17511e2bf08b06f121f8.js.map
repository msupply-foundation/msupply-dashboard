{"version":3,"sources":["webpack:///./public/app/plugins/datasource/grafana/types.ts","webpack:///./public/app/plugins/datasource/grafana/datasource.ts","webpack:///./public/app/plugins/datasource/grafana/components/QueryEditor.tsx","webpack:///./public/app/plugins/datasource/grafana/annotation_ctrl.ts","webpack:///./public/app/plugins/datasource/grafana/module.ts"],"names":["GrafanaQueryType","defaultQuery","refId","queryType","RandomWalk","GrafanaAnnotationType","counter","GrafanaDatasource","DataSourceApi","constructor","instanceSettings","super","query","request","queries","target","targets","hide","LiveMeasurements","channel","filter","startsWith","addr","parseLiveChannelAddress","isValidLiveChannelAddress","buffer","maxLength","maxDataPoints","maxDelta","rangeRaw","to","range","valueOf","from","push","getGrafanaLiveSrv","getDataStream","key","requestId","getRandomWalk","length","merge","of","metricFindQuery","options","Promise","resolve","annotationQuery","templateSrv","getTemplateSrv","annotation","params","limit","tags","matchAny","type","Dashboard","dashboard","id","dashboardId","Array","isArray","delimiter","t","renderedValues","replace","value","join","tt","split","getBackendSrv","get","name","testDatasource","intervalMs","fetch","url","method","pipe","map","rsp","toDataQueryResponse","catchError","err","QueryEditor","PureComponent","state","channels","channelFields","queryTypes","label","description","onQueryTypeChange","sel","onChange","onRunQuery","this","props","loadChannelInfo","onChannelChange","onFieldNamesChange","item","fields","v","tf","find","f","checkAndUpdateBuffer","txt","rangeUtil","intervalToSeconds","console","warn","handleEnterKey","e","handleBlur","subscribe","next","channelInfo","data","c","distinctFields","Set","frame","dataFrameFromJSON","add","n","setState","componentDidMount","renderMeasurementsQuery","currentChannel","has","formattedTime","secondsToHms","className","grow","labelWidth","allowCustomValue","backspaceRemovesValue","placeholder","isClearable","noOptionsMessage","formatCreateLabel","input","isSearchable","isMulti","width","defaultValue","onKeyDown","onBlur","spellCheck","title","severity","render","defaults","annotationTypes","text","Tags","GrafanaAnnotationsQueryCtrl","$scope","types","ctrl","templateUrl","plugin","DataSourcePlugin","setQueryEditor","setAnnotationQueryCtrl"],"mappings":"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","file":"grafanaPlugin.17511e2bf08b06f121f8.js","sourcesContent":["import { AnnotationQuery, DataQuery } from '@grafana/data';\nimport { LiveDataFilter } from '@grafana/runtime';\n\n//----------------------------------------------\n// Query\n//----------------------------------------------\n\nexport enum GrafanaQueryType {\n  RandomWalk = 'randomWalk',\n  LiveMeasurements = 'measurements',\n}\n\nexport interface GrafanaQuery extends DataQuery {\n  queryType: GrafanaQueryType; // RandomWalk by default\n  channel?: string;\n  filter?: LiveDataFilter;\n  buffer?: number;\n}\n\nexport const defaultQuery: GrafanaQuery = {\n  refId: 'A',\n  queryType: GrafanaQueryType.RandomWalk,\n};\n\n//----------------------------------------------\n// Annotations\n//----------------------------------------------\n\nexport enum GrafanaAnnotationType {\n  Dashboard = 'dashboard',\n  Tags = 'tags',\n}\n\nexport interface GrafanaAnnotationQuery extends AnnotationQuery<GrafanaQuery> {\n  type: GrafanaAnnotationType; // tags\n  limit: number; // 100\n  tags?: string[];\n  matchAny?: boolean; // By default Grafana only shows annotations that match all tags in the query. Enabling this returns annotations that match any of the tags in the query.\n}\n","import {\n  AnnotationEvent,\n  AnnotationQueryRequest,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  isValidLiveChannelAddress,\n  parseLiveChannelAddress,\n  StreamingFrameOptions,\n} from '@grafana/data';\n\nimport { GrafanaQuery, GrafanaAnnotationQuery, GrafanaAnnotationType, GrafanaQueryType } from './types';\nimport { getBackendSrv, getGrafanaLiveSrv, getTemplateSrv, toDataQueryResponse } from '@grafana/runtime';\nimport { Observable, of, merge } from 'rxjs';\nimport { map, catchError } from 'rxjs/operators';\n\nlet counter = 100;\n\nexport class GrafanaDatasource extends DataSourceApi<GrafanaQuery> {\n  constructor(instanceSettings: DataSourceInstanceSettings) {\n    super(instanceSettings);\n  }\n\n  query(request: DataQueryRequest<GrafanaQuery>): Observable<DataQueryResponse> {\n    const queries: Array<Observable<DataQueryResponse>> = [];\n    for (const target of request.targets) {\n      if (target.hide) {\n        continue;\n      }\n      if (target.queryType === GrafanaQueryType.LiveMeasurements) {\n        let { channel, filter } = target;\n\n        // Help migrate pre-release channel paths saved in dashboards\n        // NOTE: this should be removed before V8 is released\n        if (channel && channel.startsWith('telegraf/')) {\n          channel = 'stream/' + channel;\n          target.channel = channel; // mutate the current query object so it is saved with `stream/` prefix\n        }\n\n        const addr = parseLiveChannelAddress(channel);\n        if (!isValidLiveChannelAddress(addr)) {\n          continue;\n        }\n        const buffer: StreamingFrameOptions = {\n          maxLength: request.maxDataPoints ?? 500,\n        };\n        if (target.buffer) {\n          buffer.maxDelta = target.buffer;\n          buffer.maxLength = buffer.maxLength! * 2; //??\n        } else if (request.rangeRaw?.to === 'now') {\n          buffer.maxDelta = request.range.to.valueOf() - request.range.from.valueOf();\n        }\n\n        queries.push(\n          getGrafanaLiveSrv().getDataStream({\n            key: `${request.requestId}.${counter++}`,\n            addr: addr!,\n            filter,\n            buffer,\n          })\n        );\n      } else {\n        queries.push(getRandomWalk(request));\n      }\n    }\n    // With a single query just return the results\n    if (queries.length === 1) {\n      return queries[0];\n    }\n    if (queries.length > 1) {\n      return merge(...queries);\n    }\n    return of(); // nothing\n  }\n\n  metricFindQuery(options: any) {\n    return Promise.resolve([]);\n  }\n\n  annotationQuery(options: AnnotationQueryRequest<GrafanaQuery>): Promise<AnnotationEvent[]> {\n    const templateSrv = getTemplateSrv();\n    const annotation = (options.annotation as unknown) as GrafanaAnnotationQuery;\n    const params: any = {\n      from: options.range.from.valueOf(),\n      to: options.range.to.valueOf(),\n      limit: annotation.limit,\n      tags: annotation.tags,\n      matchAny: annotation.matchAny,\n    };\n\n    if (annotation.type === GrafanaAnnotationType.Dashboard) {\n      // if no dashboard id yet return\n      if (!options.dashboard.id) {\n        return Promise.resolve([]);\n      }\n      // filter by dashboard id\n      params.dashboardId = options.dashboard.id;\n      // remove tags filter if any\n      delete params.tags;\n    } else {\n      // require at least one tag\n      if (!Array.isArray(annotation.tags) || annotation.tags.length === 0) {\n        return Promise.resolve([]);\n      }\n      const delimiter = '__delimiter__';\n      const tags = [];\n      for (const t of params.tags) {\n        const renderedValues = templateSrv.replace(t, {}, (value: any) => {\n          if (typeof value === 'string') {\n            return value;\n          }\n\n          return value.join(delimiter);\n        });\n        for (const tt of renderedValues.split(delimiter)) {\n          tags.push(tt);\n        }\n      }\n      params.tags = tags;\n    }\n\n    return getBackendSrv().get(\n      '/api/annotations',\n      params,\n      `grafana-data-source-annotations-${annotation.name}-${options.dashboard?.id}`\n    );\n  }\n\n  testDatasource() {\n    return Promise.resolve();\n  }\n}\n\n// Note that the query does not actually matter\nfunction getRandomWalk(request: DataQueryRequest): Observable<DataQueryResponse> {\n  const { intervalMs, maxDataPoints, range, requestId } = request;\n\n  // Yes, this implementation ignores multiple targets!  But that matches existing behavior\n  const params: Record<string, any> = {\n    intervalMs,\n    maxDataPoints,\n    from: range.from.valueOf(),\n    to: range.to.valueOf(),\n  };\n\n  return getBackendSrv()\n    .fetch({\n      url: '/api/tsdb/testdata/random-walk',\n      method: 'GET',\n      params,\n      requestId,\n    })\n    .pipe(\n      map((rsp: any) => {\n        return toDataQueryResponse(rsp);\n      }),\n      catchError((err) => {\n        return of(toDataQueryResponse(err));\n      })\n    );\n}\n","import { defaults } from 'lodash';\n\nimport React, { PureComponent } from 'react';\nimport { InlineField, Select, Alert, Input } from '@grafana/ui';\nimport { QueryEditorProps, SelectableValue, dataFrameFromJSON, rangeUtil } from '@grafana/data';\nimport { GrafanaDatasource } from '../datasource';\nimport { defaultQuery, GrafanaQuery, GrafanaQueryType } from '../types';\nimport { getBackendSrv } from '@grafana/runtime';\n\ntype Props = QueryEditorProps<GrafanaDatasource, GrafanaQuery>;\n\nconst labelWidth = 12;\n\ninterface State {\n  channels: Array<SelectableValue<string>>;\n  channelFields: Record<string, Array<SelectableValue<string>>>;\n}\n\nexport class QueryEditor extends PureComponent<Props, State> {\n  state: State = { channels: [], channelFields: {} };\n\n  queryTypes: Array<SelectableValue<GrafanaQueryType>> = [\n    {\n      label: 'Random Walk',\n      value: GrafanaQueryType.RandomWalk,\n      description: 'Random signal within the selected time range',\n    },\n    {\n      label: 'Live Measurements',\n      value: GrafanaQueryType.LiveMeasurements,\n      description: 'Stream real-time measurements from Grafana',\n    },\n  ];\n\n  loadChannelInfo() {\n    getBackendSrv()\n      .fetch({ url: 'api/live/list' })\n      .subscribe({\n        next: (v: any) => {\n          const channelInfo = v.data?.channels as any[];\n          if (channelInfo?.length) {\n            const channelFields: Record<string, Array<SelectableValue<string>>> = {};\n            const channels: Array<SelectableValue<string>> = channelInfo.map((c) => {\n              if (c.data) {\n                const distinctFields = new Set<string>();\n                const frame = dataFrameFromJSON(c.data);\n                for (const f of frame.fields) {\n                  distinctFields.add(f.name);\n                }\n                channelFields[c.channel] = Array.from(distinctFields).map((n) => ({\n                  value: n,\n                  label: n,\n                }));\n              }\n              return {\n                value: c.channel,\n                label: c.channel,\n              };\n            });\n\n            this.setState({ channelFields, channels });\n          }\n        },\n      });\n  }\n\n  componentDidMount() {\n    this.loadChannelInfo();\n  }\n\n  onQueryTypeChange = (sel: SelectableValue<GrafanaQueryType>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, queryType: sel.value! });\n    onRunQuery();\n\n    // Reload the channel list\n    this.loadChannelInfo();\n  };\n\n  onChannelChange = (sel: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, channel: sel?.value });\n    onRunQuery();\n  };\n\n  onFieldNamesChange = (item: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    let fields: string[] = [];\n    if (Array.isArray(item)) {\n      fields = item.map((v) => v.value);\n    } else if (item.value) {\n      fields = [item.value];\n    }\n\n    // When adding the first field, also add time (if it exists)\n    if (fields.length === 1 && !query.filter?.fields?.length && query.channel) {\n      const names = this.state.channelFields[query.channel] ?? [];\n      const tf = names.find((f) => f.value === 'time' || f.value === 'Time');\n      if (tf && tf.value && tf.value !== fields[0]) {\n        fields = [tf.value, ...fields];\n      }\n    }\n\n    onChange({\n      ...query,\n      filter: {\n        ...query.filter,\n        fields,\n      },\n    });\n    onRunQuery();\n  };\n\n  checkAndUpdateBuffer = (txt: string) => {\n    const { onChange, query, onRunQuery } = this.props;\n    let buffer: number | undefined;\n    if (txt) {\n      try {\n        buffer = rangeUtil.intervalToSeconds(txt) * 1000;\n      } catch (err) {\n        console.warn('ERROR', err);\n      }\n    }\n    onChange({\n      ...query,\n      buffer,\n    });\n    onRunQuery();\n  };\n\n  handleEnterKey = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key !== 'Enter') {\n      return;\n    }\n    this.checkAndUpdateBuffer((e.target as any).value);\n  };\n\n  handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    this.checkAndUpdateBuffer(e.target.value);\n  };\n\n  renderMeasurementsQuery() {\n    let { channel, filter, buffer } = this.props.query;\n    let { channels, channelFields } = this.state;\n    let currentChannel = channels.find((c) => c.value === channel);\n    if (channel && !currentChannel) {\n      currentChannel = {\n        value: channel,\n        label: channel,\n        description: `Connected to ${channel}`,\n      };\n      channels = [currentChannel, ...channels];\n    }\n\n    const distinctFields = new Set<string>();\n    const fields: Array<SelectableValue<string>> = channel ? channelFields[channel] ?? [] : [];\n    // if (data && data.series?.length) {\n    //   for (const frame of data.series) {\n    //     for (const field of frame.fields) {\n    //       if (distinctFields.has(field.name) || !field.name) {\n    //         continue;\n    //       }\n    //       fields.push({\n    //         value: field.name,\n    //         label: field.name,\n    //         description: `(${getFrameDisplayName(frame)} / ${field.type})`,\n    //       });\n    //       distinctFields.add(field.name);\n    //     }\n    //   }\n    // }\n    if (filter?.fields) {\n      for (const f of filter.fields) {\n        if (!distinctFields.has(f)) {\n          fields.push({\n            value: f,\n            label: `${f} (not loaded)`,\n            description: `Configured, but not found in the query results`,\n          });\n          distinctFields.add(f);\n        }\n      }\n    }\n\n    let formattedTime = '';\n    if (buffer) {\n      formattedTime = rangeUtil.secondsToHms(buffer / 1000);\n    }\n\n    return (\n      <>\n        <div className=\"gf-form\">\n          <InlineField label=\"Channel\" grow={true} labelWidth={labelWidth}>\n            <Select\n              options={channels}\n              value={currentChannel || ''}\n              onChange={this.onChannelChange}\n              allowCustomValue={true}\n              backspaceRemovesValue={true}\n              placeholder=\"Select measurements channel\"\n              isClearable={true}\n              noOptionsMessage=\"Enter channel name\"\n              formatCreateLabel={(input: string) => `Connect to: ${input}`}\n            />\n          </InlineField>\n        </div>\n        {channel && (\n          <div className=\"gf-form\">\n            <InlineField label=\"Fields\" grow={true} labelWidth={labelWidth}>\n              <Select\n                options={fields}\n                value={filter?.fields || []}\n                onChange={this.onFieldNamesChange}\n                allowCustomValue={true}\n                backspaceRemovesValue={true}\n                placeholder=\"All fields\"\n                isClearable={true}\n                noOptionsMessage=\"Unable to list all fields\"\n                formatCreateLabel={(input: string) => `Field: ${input}`}\n                isSearchable={true}\n                isMulti={true}\n              />\n            </InlineField>\n            <InlineField label=\"Buffer\">\n              <Input\n                placeholder=\"Auto\"\n                width={12}\n                defaultValue={formattedTime}\n                onKeyDown={this.handleEnterKey}\n                onBlur={this.handleBlur}\n                spellCheck={false}\n              />\n            </InlineField>\n          </div>\n        )}\n\n        <Alert title=\"Grafana Live - Measurements\" severity=\"info\">\n          This supports real-time event streams in Grafana core. This feature is under heavy development. Expect the\n          interfaces and structures to change as this becomes more production ready.\n        </Alert>\n      </>\n    );\n  }\n\n  render() {\n    const query = defaults(this.props.query, defaultQuery);\n    return (\n      <>\n        <div className=\"gf-form\">\n          <InlineField label=\"Query type\" grow={true} labelWidth={labelWidth}>\n            <Select\n              options={this.queryTypes}\n              value={this.queryTypes.find((v) => v.value === query.queryType) || this.queryTypes[0]}\n              onChange={this.onQueryTypeChange}\n            />\n          </InlineField>\n        </div>\n        {query.queryType === GrafanaQueryType.LiveMeasurements && this.renderMeasurementsQuery()}\n      </>\n    );\n  }\n}\n","import { SelectableValue } from '@grafana/data';\nimport { GrafanaAnnotationType } from './types';\n\nexport const annotationTypes: Array<SelectableValue<GrafanaAnnotationType>> = [\n  { text: 'Dashboard', value: GrafanaAnnotationType.Dashboard },\n  { text: 'Tags', value: GrafanaAnnotationType.Tags },\n];\n\nexport class GrafanaAnnotationsQueryCtrl {\n  declare annotation: any;\n\n  types = annotationTypes;\n\n  /** @ngInject */\n  constructor($scope: any) {\n    this.annotation = $scope.ctrl.annotation;\n    this.annotation.type = this.annotation.type || GrafanaAnnotationType.Tags;\n    this.annotation.limit = this.annotation.limit || 100;\n  }\n\n  static templateUrl = 'partials/annotations.editor.html';\n}\n","import { DataSourcePlugin } from '@grafana/data';\nimport { GrafanaDatasource } from './datasource';\nimport { QueryEditor } from './components/QueryEditor';\nimport { GrafanaQuery } from './types';\nimport { GrafanaAnnotationsQueryCtrl } from './annotation_ctrl';\n\nexport const plugin = new DataSourcePlugin<GrafanaDatasource, GrafanaQuery>(GrafanaDatasource)\n  .setQueryEditor(QueryEditor)\n  .setAnnotationQueryCtrl(GrafanaAnnotationsQueryCtrl);\n"],"sourceRoot":""}