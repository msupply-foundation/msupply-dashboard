{"version":3,"sources":["webpack:///./public/app/core/components/TraceToLogsSettings.tsx","webpack:///./public/app/plugins/datasource/tempo/graphTransform.ts","webpack:///./public/app/plugins/datasource/tempo/resultTransformer.ts","webpack:///./public/app/plugins/datasource/tempo/datasource.ts","webpack:///./public/app/plugins/datasource/tempo/QueryField.tsx","webpack:///./public/app/plugins/datasource/tempo/module.ts","webpack:///./public/app/plugins/datasource/tempo/ConfigEditor.tsx","webpack:///./public/app/plugins/datasource/tempo/CheatSheet.tsx","webpack:///./public/app/core/utils/tracing.ts"],"names":["TraceToLogsSettings","options","onOptionsChange","styles","useStyles","getStyles","className","css","width","infoText","tooltip","label","labelWidth","pluginId","current","jsonData","tracesToLogs","datasourceUid","noDefault","onChange","ds","updateDatasourcePluginJsonDataOption","uid","tags","theme","spacing","md","colors","textSemiWeak","createGraphFrames","data","nodes","edges","view","DataFrameView","traceDuration","traceEndTime","traceStartTime","Infinity","i","length","row","get","startTime","duration","findTraceDuration","spanMap","makeSpanMap","index","span","id","spanID","parentIds","parentSpanID","ranges","children","map","c","childrenDuration","getNonOverlappingDuration","selfDuration","stats","getStats","push","Fields","title","serviceName","subTitle","operationName","mainStat","main","secondaryStat","secondary","color","target","source","convertTraceToGraph","nodesFrame","edgesFrame","makeFrames","node","add","edge","transformTraceList","response","datasourceId","datasourceName","traceRegexs","forEach","frame","logsFrame","tableFrame","MutableDataFrame","fields","name","type","FieldType","time","config","custom","string","displayNameFromDS","links","url","internal","query","meta","preferredVisualisationType","timeField","find","f","field","hasMatch","values","toArray","line","traceRegex","match","traceId","createTableFrame","transformTrace","fieldName","fieldIndex","indexOf","ArrayVector","newField","other","value","set","undefined","JSON","parse","parseJsonFields","emptyDataQueryResponse","trace","TempoDatasource","DataSourceWithBackend","constructor","instanceSettings","super","this","subQueries","filteredTargets","targets","filter","hide","searchTargets","queryType","traceTargets","dsSrv","getDatasourceSrv","from","pipe","mergeMap","linkedDatasource","linkedRequest","t","linkedQuery","traceLinkMatcher","derivedFields","matcherRegex","error","throwError","traceRequest","merge","errorMessage","toPromise","message","startsWith","endsWith","status","getQueryDisplayText","TempoQueryField","React","PureComponent","props","state","onChangeLinkedQuery","refId","onRunLinkedQuery","onRunQuery","datasource","linkedDatasourceUid","getDataSourceSrv","setState","render","v","size","LokiQueryField","history","FormField","inputEl","aria-label","selectors","components","QueryField","container","style","e","currentTarget","plugin","DataSourcePlugin","setConfigEditor","defaultUrl","dataSourceConfig","showAccessOptions","setQueryEditorHelp","href","setExploreQueryField","sort","a","b","reduce","acc","range","tail","slice","prevStart","prevEnd","start","end","getSpan","parentId","toFixedNoTrailingZeros","n","parseFloat","toFixed","displayName","number","mode"],"mappings":"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","file":"tempoPlugin.17511e2bf08b06f121f8.js","sourcesContent":["import { css } from '@emotion/css';\nimport {\n  DataSourceJsonData,\n  DataSourcePluginOptionsEditorProps,\n  GrafanaTheme,\n  updateDatasourcePluginJsonDataOption,\n} from '@grafana/data';\nimport { DataSourcePicker } from '@grafana/runtime';\nimport { InlineField, InlineFieldRow, TagsInput, useStyles } from '@grafana/ui';\nimport React from 'react';\n\nexport interface TraceToLogsOptions {\n  datasourceUid?: string;\n  tags?: string[];\n}\n\nexport interface TraceToLogsData extends DataSourceJsonData {\n  tracesToLogs?: TraceToLogsOptions;\n}\n\ninterface Props extends DataSourcePluginOptionsEditorProps<TraceToLogsData> {}\n\nexport function TraceToLogsSettings({ options, onOptionsChange }: Props) {\n  const styles = useStyles(getStyles);\n\n  return (\n    <div className={css({ width: '100%' })}>\n      <h3 className=\"page-heading\">Trace to logs</h3>\n\n      <div className={styles.infoText}>\n        Trace to logs let&apos;s you navigate from a trace span to the selected data source&apos;s log.\n      </div>\n\n      <InlineFieldRow>\n        <InlineField tooltip=\"The data source the trace is going to navigate to\" label=\"Data source\" labelWidth={26}>\n          <DataSourcePicker\n            pluginId=\"loki\"\n            current={options.jsonData.tracesToLogs?.datasourceUid}\n            noDefault={true}\n            width={40}\n            onChange={(ds) =>\n              updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n                datasourceUid: ds.uid,\n                tags: options.jsonData.tracesToLogs?.tags,\n              })\n            }\n          />\n        </InlineField>\n      </InlineFieldRow>\n\n      <InlineFieldRow>\n        <InlineField\n          tooltip=\"Tags that will be used in the Loki query. Default tags: 'cluster', 'hostname', 'namespace', 'pod'\"\n          label=\"Tags\"\n          labelWidth={26}\n        >\n          <TagsInput\n            tags={options.jsonData.tracesToLogs?.tags}\n            width={40}\n            onChange={(tags) =>\n              updateDatasourcePluginJsonDataOption({ onOptionsChange, options }, 'tracesToLogs', {\n                datasourceUid: options.jsonData.tracesToLogs?.datasourceUid,\n                tags: tags,\n              })\n            }\n          />\n        </InlineField>\n      </InlineFieldRow>\n    </div>\n  );\n}\n\nconst getStyles = (theme: GrafanaTheme) => ({\n  infoText: css`\n    padding-bottom: ${theme.spacing.md};\n    color: ${theme.colors.textSemiWeak};\n  `,\n});\n","import { DataFrame, DataFrameView, NodeGraphDataFrameFieldNames as Fields } from '@grafana/data';\nimport { getNonOverlappingDuration, getStats, makeFrames, makeSpanMap } from '../../../core/utils/tracing';\n\ninterface Row {\n  traceID: string;\n  spanID: string;\n  parentSpanID: string;\n  operationName: string;\n  serviceName: string;\n  serviceTags: string;\n  startTime: number;\n  duration: number;\n  logs: string;\n  tags: string;\n}\n\ninterface Node {\n  [Fields.id]: string;\n  [Fields.title]: string;\n  [Fields.subTitle]: string;\n  [Fields.mainStat]: string;\n  [Fields.secondaryStat]: string;\n  [Fields.color]: number;\n}\n\ninterface Edge {\n  [Fields.id]: string;\n  [Fields.target]: string;\n  [Fields.source]: string;\n}\n\nexport function createGraphFrames(data: DataFrame): DataFrame[] {\n  const { nodes, edges } = convertTraceToGraph(data);\n  const [nodesFrame, edgesFrame] = makeFrames();\n\n  for (const node of nodes) {\n    nodesFrame.add(node);\n  }\n  for (const edge of edges) {\n    edgesFrame.add(edge);\n  }\n\n  return [nodesFrame, edgesFrame];\n}\n\nfunction convertTraceToGraph(data: DataFrame): { nodes: Node[]; edges: Edge[] } {\n  const nodes: Node[] = [];\n  const edges: Edge[] = [];\n\n  const view = new DataFrameView<Row>(data);\n\n  const traceDuration = findTraceDuration(view);\n  const spanMap = makeSpanMap((index) => {\n    if (index >= data.length) {\n      return undefined;\n    }\n    const span = view.get(index);\n    return {\n      span: { ...span },\n      id: span.spanID,\n      parentIds: span.parentSpanID ? [span.parentSpanID] : [],\n    };\n  });\n\n  for (let i = 0; i < view.length; i++) {\n    const row = view.get(i);\n\n    const ranges: Array<[number, number]> = spanMap[row.spanID].children.map((c) => {\n      const span = spanMap[c].span;\n      return [span.startTime, span.startTime + span.duration];\n    });\n    const childrenDuration = getNonOverlappingDuration(ranges);\n    const selfDuration = row.duration - childrenDuration;\n    const stats = getStats(row.duration, traceDuration, selfDuration);\n\n    nodes.push({\n      [Fields.id]: row.spanID,\n      [Fields.title]: row.serviceName ?? '',\n      [Fields.subTitle]: row.operationName,\n      [Fields.mainStat]: stats.main,\n      [Fields.secondaryStat]: stats.secondary,\n      [Fields.color]: selfDuration / traceDuration,\n    });\n\n    // Sometimes some span can be missing. Don't add edges for those.\n    if (row.parentSpanID && spanMap[row.parentSpanID].span) {\n      edges.push({\n        [Fields.id]: row.parentSpanID + '--' + row.spanID,\n        [Fields.target]: row.spanID,\n        [Fields.source]: row.parentSpanID,\n      });\n    }\n  }\n\n  return { nodes, edges };\n}\n\n/**\n * Get the duration of the whole trace as it isn't a part of the response data.\n * Note: Seems like this should be the same as just longest span, but this is probably safer.\n */\nfunction findTraceDuration(view: DataFrameView<Row>): number {\n  let traceEndTime = 0;\n  let traceStartTime = Infinity;\n\n  for (let i = 0; i < view.length; i++) {\n    const row = view.get(i);\n\n    if (row.startTime < traceStartTime) {\n      traceStartTime = row.startTime;\n    }\n\n    if (row.startTime + row.duration > traceEndTime) {\n      traceEndTime = row.startTime + row.duration;\n    }\n  }\n\n  return traceEndTime - traceStartTime;\n}\n","import { DataQueryResponse, ArrayVector, DataFrame, Field, FieldType, MutableDataFrame } from '@grafana/data';\nimport { createGraphFrames } from './graphTransform';\n\nexport function createTableFrame(\n  logsFrame: DataFrame,\n  datasourceUid: string,\n  datasourceName: string,\n  traceRegexs: string[]\n): DataFrame {\n  const tableFrame = new MutableDataFrame({\n    fields: [\n      {\n        name: 'Time',\n        type: FieldType.time,\n        config: {\n          custom: {\n            width: 150,\n          },\n        },\n      },\n      {\n        name: 'traceID',\n        type: FieldType.string,\n        config: {\n          displayNameFromDS: 'Trace ID',\n          custom: { width: 300 },\n          links: [\n            {\n              title: 'Click to open trace ${__value.raw}',\n              url: '',\n              internal: {\n                datasourceUid,\n                datasourceName,\n                query: {\n                  query: '${__value.raw}',\n                },\n              },\n            },\n          ],\n        },\n      },\n      {\n        name: 'Message',\n        type: FieldType.string,\n      },\n    ],\n    meta: {\n      preferredVisualisationType: 'table',\n    },\n  });\n\n  if (!logsFrame || traceRegexs.length === 0) {\n    return tableFrame;\n  }\n\n  const timeField = logsFrame.fields.find((f) => f.type === FieldType.time);\n\n  // Going through all string fields to look for trace IDs\n  for (let field of logsFrame.fields) {\n    let hasMatch = false;\n    if (field.type === FieldType.string) {\n      const values = field.values.toArray();\n      for (let i = 0; i < values.length; i++) {\n        const line = values[i];\n        if (line) {\n          for (let traceRegex of traceRegexs) {\n            const match = (line as string).match(traceRegex);\n            if (match) {\n              const traceId = match[1];\n              const time = timeField ? timeField.values.get(i) : null;\n              tableFrame.fields[0].values.add(time);\n              tableFrame.fields[1].values.add(traceId);\n              tableFrame.fields[2].values.add(line);\n              hasMatch = true;\n            }\n          }\n        }\n      }\n    }\n    if (hasMatch) {\n      break;\n    }\n  }\n\n  return tableFrame;\n}\n\nexport function transformTraceList(\n  response: DataQueryResponse,\n  datasourceId: string,\n  datasourceName: string,\n  traceRegexs: string[]\n): DataQueryResponse {\n  response.data.forEach((data, index) => {\n    const frame = createTableFrame(data, datasourceId, datasourceName, traceRegexs);\n    response.data[index] = frame;\n  });\n  return response;\n}\n\nexport function transformTrace(response: DataQueryResponse): DataQueryResponse {\n  // We need to parse some of the fields which contain stringified json.\n  // Seems like we can't just map the values as the frame we got from backend has some default processing\n  // and will stringify the json back when we try to set it. So we create a new field and swap it instead.\n  const frame: DataFrame = response.data[0];\n\n  if (!frame) {\n    return emptyDataQueryResponse;\n  }\n\n  parseJsonFields(frame);\n\n  return {\n    ...response,\n    data: [...response.data, ...createGraphFrames(frame)],\n  };\n}\n\n/**\n * Change fields which are json string into JS objects. Modifies the frame in place.\n */\nfunction parseJsonFields(frame: DataFrame) {\n  for (const fieldName of ['serviceTags', 'logs', 'tags']) {\n    const field = frame.fields.find((f) => f.name === fieldName);\n    if (field) {\n      const fieldIndex = frame.fields.indexOf(field);\n      const values = new ArrayVector();\n      const newField: Field = {\n        ...field,\n        values,\n        type: FieldType.other,\n      };\n\n      for (let i = 0; i < field.values.length; i++) {\n        const value = field.values.get(i);\n        values.set(i, value === '' ? undefined : JSON.parse(value));\n      }\n      frame.fields[fieldIndex] = newField;\n    }\n  }\n}\n\nconst emptyDataQueryResponse = {\n  data: [\n    new MutableDataFrame({\n      fields: [\n        {\n          name: 'trace',\n          type: FieldType.trace,\n          values: [],\n        },\n      ],\n      meta: {\n        preferredVisualisationType: 'trace',\n      },\n    }),\n  ],\n};\n","import {\n  DataQuery,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n} from '@grafana/data';\nimport { DataSourceWithBackend } from '@grafana/runtime';\nimport { TraceToLogsData, TraceToLogsOptions } from 'app/core/components/TraceToLogsSettings';\nimport { getDatasourceSrv } from 'app/features/plugins/datasource_srv';\nimport { from, merge, Observable, throwError } from 'rxjs';\nimport { map, mergeMap } from 'rxjs/operators';\nimport { LokiOptions } from '../loki/types';\nimport { transformTrace, transformTraceList } from './resultTransformer';\n\nexport type TempoQueryType = 'search' | 'traceId';\n\nexport type TempoQuery = {\n  query: string;\n  // Query to find list of traces, e.g., via Loki\n  linkedQuery?: DataQuery;\n  queryType: TempoQueryType;\n} & DataQuery;\n\nexport class TempoDatasource extends DataSourceWithBackend<TempoQuery, TraceToLogsData> {\n  tracesToLogs?: TraceToLogsOptions;\n\n  constructor(instanceSettings: DataSourceInstanceSettings<TraceToLogsData>) {\n    super(instanceSettings);\n    this.tracesToLogs = instanceSettings.jsonData.tracesToLogs;\n  }\n\n  query(options: DataQueryRequest<TempoQuery>): Observable<DataQueryResponse> {\n    const subQueries: Array<Observable<DataQueryResponse>> = [];\n    const filteredTargets = options.targets.filter((target) => !target.hide);\n    const searchTargets = filteredTargets.filter((target) => target.queryType === 'search');\n    const traceTargets = filteredTargets.filter(\n      (target) => target.queryType === 'traceId' || target.queryType === undefined\n    );\n\n    // Run search queries on linked datasource\n    if (this.tracesToLogs?.datasourceUid && searchTargets.length > 0) {\n      const dsSrv = getDatasourceSrv();\n      subQueries.push(\n        from(dsSrv.get(this.tracesToLogs.datasourceUid)).pipe(\n          mergeMap((linkedDatasource: DataSourceApi) => {\n            // Wrap linked query into a data request based on original request\n            const linkedRequest: DataQueryRequest = { ...options, targets: searchTargets.map((t) => t.linkedQuery!) };\n            // Find trace matchers in derived fields of the linked datasource that's identical to this datasource\n            const settings: DataSourceInstanceSettings<LokiOptions> = (linkedDatasource as any).instanceSettings;\n            const traceLinkMatcher: string[] =\n              settings.jsonData.derivedFields\n                ?.filter((field) => field.datasourceUid === this.uid && field.matcherRegex)\n                .map((field) => field.matcherRegex) || [];\n            if (!traceLinkMatcher || traceLinkMatcher.length === 0) {\n              return throwError(\n                'No Loki datasource configured for search. Set up Derived Fields for traces in a Loki datasource settings and link it to this Tempo datasource.'\n              );\n            } else {\n              return (linkedDatasource.query(linkedRequest) as Observable<DataQueryResponse>).pipe(\n                map((response) =>\n                  response.error ? response : transformTraceList(response, this.uid, this.name, traceLinkMatcher)\n                )\n              );\n            }\n          })\n        )\n      );\n    }\n\n    if (traceTargets.length > 0) {\n      const traceRequest: DataQueryRequest<TempoQuery> = { ...options, targets: traceTargets };\n      subQueries.push(\n        super.query(traceRequest).pipe(\n          map((response) => {\n            if (response.error) {\n              return response;\n            }\n            return transformTrace(response);\n          })\n        )\n      );\n    }\n\n    return merge(...subQueries);\n  }\n\n  async testDatasource(): Promise<any> {\n    // to test Tempo we send a dummy traceID and verify Tempo answers with 'trace not found'\n    const response = await super.query({ targets: [{ query: '0' }] } as any).toPromise();\n\n    const errorMessage = response.error?.message;\n    if (\n      errorMessage &&\n      errorMessage.startsWith('failed to get trace') &&\n      errorMessage.endsWith('trace not found in Tempo')\n    ) {\n      return { status: 'success', message: 'Data source is working' };\n    }\n\n    return { status: 'error', message: 'Data source is not working' + (errorMessage ? `: ${errorMessage}` : '') };\n  }\n\n  getQueryDisplayText(query: TempoQuery) {\n    return query.query;\n  }\n}\n","import { DataQuery, DataSourceApi, ExploreQueryFieldProps } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { getDataSourceSrv } from '@grafana/runtime';\nimport { InlineField, InlineFieldRow, InlineLabel, LegacyForms, RadioButtonGroup } from '@grafana/ui';\nimport { TraceToLogsOptions } from 'app/core/components/TraceToLogsSettings';\nimport React from 'react';\nimport { LokiQueryField } from '../loki/components/LokiQueryField';\nimport { TempoDatasource, TempoQuery, TempoQueryType } from './datasource';\n\ntype Props = ExploreQueryFieldProps<TempoDatasource, TempoQuery>;\nconst DEFAULT_QUERY_TYPE: TempoQueryType = 'traceId';\ninterface State {\n  linkedDatasource?: DataSourceApi;\n}\nexport class TempoQueryField extends React.PureComponent<Props, State> {\n  state = {\n    linkedDatasource: undefined,\n  };\n\n  constructor(props: Props) {\n    super(props);\n  }\n\n  async componentDidMount() {\n    const { datasource } = this.props;\n    // Find query field from linked datasource\n    const tracesToLogsOptions: TraceToLogsOptions = datasource.tracesToLogs || {};\n    const linkedDatasourceUid = tracesToLogsOptions.datasourceUid;\n    if (linkedDatasourceUid) {\n      const dsSrv = getDataSourceSrv();\n      const linkedDatasource = await dsSrv.get(linkedDatasourceUid);\n      this.setState({\n        linkedDatasource,\n      });\n    }\n  }\n\n  onChangeLinkedQuery = (value: DataQuery) => {\n    const { query, onChange } = this.props;\n    onChange({\n      ...query,\n      linkedQuery: { ...value, refId: 'linked' },\n    });\n  };\n\n  onRunLinkedQuery = () => {\n    this.props.onRunQuery();\n  };\n\n  render() {\n    const { query, onChange } = this.props;\n    const { linkedDatasource } = this.state;\n\n    return (\n      <>\n        <InlineFieldRow>\n          <InlineField label=\"Query type\">\n            <RadioButtonGroup<TempoQueryType>\n              options={[\n                { value: 'search', label: 'Search' },\n                { value: 'traceId', label: 'TraceID' },\n              ]}\n              value={query.queryType || DEFAULT_QUERY_TYPE}\n              onChange={(v) =>\n                onChange({\n                  ...query,\n                  queryType: v,\n                })\n              }\n              size=\"md\"\n            />\n          </InlineField>\n        </InlineFieldRow>\n        {query.queryType === 'search' && linkedDatasource && (\n          <>\n            <InlineLabel>\n              Tempo uses {((linkedDatasource as unknown) as DataSourceApi).name} to find traces.\n            </InlineLabel>\n\n            <LokiQueryField\n              datasource={linkedDatasource!}\n              onChange={this.onChangeLinkedQuery}\n              onRunQuery={this.onRunLinkedQuery}\n              query={this.props.query.linkedQuery ?? ({ refId: 'linked' } as any)}\n              history={[]}\n            />\n          </>\n        )}\n        {query.queryType === 'search' && !linkedDatasource && (\n          <div className=\"text-warning\">Please set up a Traces-to-logs datasource in the datasource settings.</div>\n        )}\n        {query.queryType !== 'search' && (\n          <LegacyForms.FormField\n            label=\"Trace ID\"\n            labelWidth={4}\n            inputEl={\n              <div className=\"slate-query-field__wrapper\">\n                <div className=\"slate-query-field\" aria-label={selectors.components.QueryField.container}>\n                  <input\n                    style={{ width: '100%' }}\n                    value={query.query || ''}\n                    onChange={(e) =>\n                      onChange({\n                        ...query,\n                        query: e.currentTarget.value,\n                        queryType: 'traceId',\n                        linkedQuery: undefined,\n                      })\n                    }\n                  />\n                </div>\n              </div>\n            }\n          />\n        )}\n      </>\n    );\n  }\n}\n","import { DataSourcePlugin } from '@grafana/data';\nimport CheatSheet from './CheatSheet';\nimport { ConfigEditor } from './ConfigEditor';\nimport { TempoDatasource } from './datasource';\nimport { TempoQueryField } from './QueryField';\n\nexport const plugin = new DataSourcePlugin(TempoDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setQueryEditorHelp(CheatSheet)\n  .setExploreQueryField(TempoQueryField);\n","import { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { TraceToLogsSettings } from 'app/core/components/TraceToLogsSettings';\nimport React from 'react';\n\nexport type Props = DataSourcePluginOptionsEditorProps;\n\nexport const ConfigEditor: React.FC<Props> = ({ options, onOptionsChange }) => {\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://tempo\"\n        dataSourceConfig={options}\n        showAccessOptions={false}\n        onChange={onOptionsChange}\n      />\n\n      <TraceToLogsSettings options={options} onOptionsChange={onOptionsChange} />\n    </>\n  );\n};\n","import React from 'react';\n\nexport default function CheatSheet() {\n  return (\n    <div>\n      <h2 id=\"tempo-cheat-sheet\">Tempo Cheat Sheet</h2>\n      <p>\n        Tempo is a trace id lookup store. Enter a trace id in the above field and hit “Run Query” to retrieve your\n        trace. Tempo is generally paired with other datasources such as Loki or Prometheus to find traces.\n      </p>\n      <p>\n        Here are some{' '}\n        <a href=\"https://grafana.com/docs/tempo/latest/guides/instrumentation/\" target=\"blank\">\n          instrumentation examples\n        </a>{' '}\n        to get you started with trace discovery through logs and metrics (exemplars).\n      </p>\n    </div>\n  );\n}\n","/**\n * Get non overlapping duration of the ranges as they can overlap or have gaps.\n */\nimport { FieldType, MutableDataFrame, NodeGraphDataFrameFieldNames as Fields } from '@grafana/data';\n\nexport function getNonOverlappingDuration(ranges: Array<[number, number]>): number {\n  ranges.sort((a, b) => a[0] - b[0]);\n  const mergedRanges = ranges.reduce((acc, range) => {\n    if (!acc.length) {\n      return [range];\n    }\n    const tail = acc.slice(-1)[0];\n    const [prevStart, prevEnd] = tail;\n    const [start, end] = range;\n    if (end < prevEnd) {\n      // In this case the range is completely inside the prev range so we can just ignore it.\n      return acc;\n    }\n\n    if (start > prevEnd) {\n      // There is no overlap so we can just add it to stack\n      return [...acc, range];\n    }\n\n    // We know there is overlap and current range ends later than previous so we can just extend the range\n    return [...acc.slice(0, -1), [prevStart, end]] as Array<[number, number]>;\n  }, [] as Array<[number, number]>);\n\n  return mergedRanges.reduce((acc, range) => {\n    return acc + (range[1] - range[0]);\n  }, 0);\n}\n\n/**\n * Returns a map of the spans with children array for easier processing. It will also contain empty spans in case\n * span is missing but other spans are it's children. This is more generic because it needs to allow iterating over\n * both arrays and dataframe views.\n */\nexport function makeSpanMap<T>(\n  getSpan: (index: number) => { span: T; id: string; parentIds: string[] } | undefined\n): { [id: string]: { span: T; children: string[] } } {\n  const spanMap: { [id: string]: { span?: T; children: string[] } } = {};\n\n  let span;\n  for (let index = 0; (span = getSpan(index)), !!span; index++) {\n    if (!spanMap[span.id]) {\n      spanMap[span.id] = {\n        span: span.span,\n        children: [],\n      };\n    } else {\n      spanMap[span.id].span = span.span;\n    }\n\n    for (const parentId of span.parentIds) {\n      if (parentId) {\n        if (!spanMap[parentId]) {\n          spanMap[parentId] = {\n            span: undefined,\n            children: [span.id],\n          };\n        } else {\n          spanMap[parentId].children.push(span.id);\n        }\n      }\n    }\n  }\n  return spanMap as { [id: string]: { span: T; children: string[] } };\n}\n\nexport function getStats(duration: number, traceDuration: number, selfDuration: number) {\n  return {\n    main: `${toFixedNoTrailingZeros(duration)}ms (${toFixedNoTrailingZeros((duration / traceDuration) * 100)}%)`,\n    secondary: `${toFixedNoTrailingZeros(selfDuration)}ms (${toFixedNoTrailingZeros(\n      (selfDuration / duration) * 100\n    )}%)`,\n  };\n}\n\nfunction toFixedNoTrailingZeros(n: number) {\n  return parseFloat(n.toFixed(2));\n}\n\n/**\n * Create default frames used when returning data for node graph.\n */\nexport function makeFrames() {\n  const nodesFrame = new MutableDataFrame({\n    fields: [\n      { name: Fields.id, type: FieldType.string },\n      { name: Fields.title, type: FieldType.string },\n      { name: Fields.subTitle, type: FieldType.string },\n      { name: Fields.mainStat, type: FieldType.string, config: { displayName: 'Total time (% of trace)' } },\n      { name: Fields.secondaryStat, type: FieldType.string, config: { displayName: 'Self time (% of total)' } },\n      {\n        name: Fields.color,\n        type: FieldType.number,\n        config: { color: { mode: 'continuous-GrYlRd' }, displayName: 'Self time / Trace duration' },\n      },\n    ],\n    meta: {\n      preferredVisualisationType: 'nodeGraph',\n    },\n  });\n\n  const edgesFrame = new MutableDataFrame({\n    fields: [\n      { name: Fields.id, type: FieldType.string },\n      { name: Fields.target, type: FieldType.string },\n      { name: Fields.source, type: FieldType.string },\n    ],\n    meta: {\n      preferredVisualisationType: 'nodeGraph',\n    },\n  });\n\n  return [nodesFrame, edgesFrame];\n}\n"],"sourceRoot":""}