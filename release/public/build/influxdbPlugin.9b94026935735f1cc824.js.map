{"version":3,"sources":["webpack:///./node_modules/debounce-promise/dist/index.js","webpack:///./public/app/plugins/datasource/influxdb/influx_series.ts","webpack:///./public/app/plugins/datasource/influxdb/query_part.ts","webpack:///./public/app/plugins/datasource/influxdb/influx_query_model.ts","webpack:///./public/app/plugins/datasource/influxdb/response_parser.ts","webpack:///./public/app/plugins/datasource/influxdb/query_builder.ts","webpack:///./public/app/plugins/datasource/influxdb/types.ts","webpack:///./public/app/plugins/datasource/influxdb/components/FluxQueryEditor.tsx","webpack:///./public/app/plugins/datasource/influxdb/queryUtils.ts","webpack:///./public/app/plugins/datasource/influxdb/datasource.ts","webpack:///./public/app/plugins/datasource/influxdb/components/useShadowedState.ts","webpack:///./public/app/plugins/datasource/influxdb/components/useUniqueId.ts","webpack:///./public/app/plugins/datasource/influxdb/components/constants.ts","webpack:///./public/app/plugins/datasource/influxdb/components/RawInfluxQLEditor.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/Seg.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/toSelectableValue.ts","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/FromSection.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/tagUtils.ts","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/unwrap.ts","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/AddButton.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/TagsSection.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/PartListSection.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/styles.ts","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/OrderByTimeSection.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/InputSection.tsx","webpack:///./public/app/plugins/datasource/influxdb/influxQLMetadataQuery.ts","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/FormatAsSection.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/SectionLabel.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/SectionFill.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/partListUtils.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/Editor.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/QueryEditorModeSwitcher.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxCheatSheet.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxStartPage.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/ConfigEditor.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/VariableQueryEditor.tsx","webpack:///./public/app/plugins/datasource/influxdb/module.ts","webpack:///./public/app/plugins/datasource/influxdb/components/QueryEditor.tsx","webpack:///./node_modules/react-use/esm/usePrevious.js"],"names":["getWait","wait","defer","deferred","promise","Promise","resolve","reject","module","exports","fn","arguments","length","undefined","options","lastCallAt","timer","pendingArgs","currentWait","currentTime","Date","getTime","isCold","_len","args","Array","_key","leading","accumulate","call","this","then","result","apply","concat","clearTimeout","push","setTimeout","flush","bind","argsIndex","results","thisDeferred","InfluxSeries","constructor","series","alias","annotation","meta","refId","getTimeSeries","output","i","j","each","columns","tags","map","value","key","seriesName","name","columnName","_getSeriesName","join","datapoints","values","title","target","index","segments","split","replace","match","g1","g2","group","segIndex","parseInt","isNaN","indexOf","tag","getAnnotations","list","titleCol","timeCol","timeEndCol","tagsCol","textCol","column","titleColumn","includes","tagsColumn","textColumn","timeEndColumn","data","time","timeEnd","flatten","filter","t","text","getTable","table","TableModel","seriesIndex","type","FieldType","keys","reordered","hasOwnProperty","rows","categories","Aggregations","Selectors","Transformations","Predictors","Math","Aliasing","Fields","createPart","part","def","message","QueryPart","register","QueryPartDef","category","groupByTimeFunctions","fieldRenderer","innerExpr","params","replaceAggregationAddStrategy","selectParts","partModel","morePartsAvailable","splice","addTransformationStrategy","addStrategy","query","parts","clone","selectModels","dynamicLookup","defaultParams","renderer","functionRenderer","partCount","suffixRenderer","quote","renderMode","create","getCategories","replaceAggregationAdd","InfluxQueryModel","templateSrv","scopedVars","policy","resultFormat","orderByTime","groupBy","select","updateProjection","queryPart","groupByParts","updatePersistedParts","hasGroupByTime","find","g","hasFill","addGroupBy","stringParts","typePart","arg","removeGroupByPart","s","removeSelect","removeSelectPart","modelsIndex","partIndex","addSelectPart","renderTagCondition","interpolate","str","operator","condition","test","getMeasurementAndPolicy","measurement","interpolateQueryStr","variable","defaultFormatFn","multi","includeAll","kbn","regexEscape","render","rawQuery","y","selectText","conditions","groupBySection","fill","limit","slimit","tz","renderAdhocFilters","filters","ResponseParser","parse","influxResults","normalizedQuery","toLowerCase","isValueFirst","res","Set","serie","isArray","addUnique","from","v","add","toString","InfluxQueryBuilder","database","buildExploreQuery","withKey","withMeasurementFilter","whereConditions","reduce","memo","InfluxVersion","samples","label","description","FluxQueryEditor","PureComponent","props","onChange","onRunQuery","val","forceUpdate","sugs","kind","CodeEditorSuggestionItemKind","Property","detail","getTemplateSrv","getVariables","forEach","Text","editor","layout","helpTooltip","height","language","onBlur","onFluxQueryChange","onSave","showMiniMap","showLineNumbers","getSuggestions","onEditorDidMount","editorDidMountCallbackHack","className","cx","css","icon","variant","href","onSampleChange","width","tooltip","buildRawQuery","queryCopy","cloneDeep","getFieldType","firstNotNull","number","valueType","string","boolean","Error","timeSeriesToDataFrame","timeSeries","times","points","point","fields","TIME_SERIES_TIME_FIELD_NAME","config","ArrayVector","TIME_SERIES_VALUE_FIELD_NAME","displayNameFromDS","labels","InfluxDatasource","DataSourceWithBackend","instanceSettings","super","urls","url","trim","username","password","basicAuth","withCredentials","settingsData","jsonData","interval","timeInterval","httpMode","responseParser","isFlux","version","Flux","annotations","QueryEditor","request","filteredRequest","targets","hide","classicQuery","getQueryDisplayText","filterQuery","applyTemplateVariables","timeFilter","getTimeFilter","queryTargets","allQueries","_map","__interval","acc","current","of","adhocFilters","getAdhocFilters","_seriesQuery","pipe","seriesList","executedQueryString","influxSeries","preferredVisualisationType","rangeRaw","timezone","dashboard","toPromise","targetContainsTemplate","queryText","variableExists","interpolateVariablesInQueries","queries","expandedQueries","expandedQuery","datasource","rsp","frameToMetricFindValue","interpolated","resp","getTagKeys","metricFindQuery","getTagValues","range","_influxRequest","q","epoch","serializeParams","encodeURIComponent","testDatasource","requestId","id","uuidv4","dashboardId","panelId","intervalMs","maxDataPoints","dateTime","to","state","LoadingState","Done","console","error","status","first","catch","err","get","method","currentUrl","shift","u","p","db","has","extend","omit","pick","req","precision","inspect","paramSerializer","headers","Authorization","getBackendSrv","fetch","errors","elem","catchError","cancelled","throwError","handleErrors","Number","isInteger","statusText","getInfluxTime","date","roundUp","isString","exec","dateMath","valueOf","useShadowedState","outsideVal","currentVal","setCurrentVal","useState","prevOutsideVal","usePrevious","useEffect","useUniqueId","idRefLazy","useRef","uniqueId","RESULT_FORMATS","RawInfluxQLEditor","currentQuery","setCurrentQuery","currentAlias","setCurrentAlias","aliasElementId","selectElementId","applyDelayedChangesAndRunQuery","aria-label","spellCheck","placeholder","e","currentTarget","htmlFor","menuShouldPortal","inputId","selectClass","minWidth","formatCreateLabel","SelReload","loadOptions","allowCustomValue","onClose","debouncedLoadOptions","debouncePromise","defaultOptions","autoFocus","isOpen","onCloseMenu","SelSingleLoad","loadState","doLoad","useAsyncFn","isLoading","loading","Sel","filterByLoadOptions","Inp","initialValue","currentValue","setCurrentValue","onKeyDown","defaultButtonClass","cursor","Seg","buttonClassName","setOpen","as","onClick","toSelectableValue","FromSection","getPolicyOptions","getMeasurementOptions","async","allPolicies","some","isRegex","getOperator","getCondition","isFirst","adjustOperatorIfNeeded","currentOperator","newTagValue","isCurrentOperatorRegex","unwrap","AddButton","onAdd","operatorOptions","condititonOptions","loadConditionOptions","loadOperatorOptions","Tag","onRemove","getTagKeyOptions","getTagValueOptions","op","TagsSection","newT","newTag","newTags","onTagChange","onTagRemove","tagKey","minimalTag","addNewTag","noRightMarginPaddingClass","paddingRight","marginRight","RemovableName","renderMenuItems","renderRemovableNameMenuItems","ariaLabel","openMenu","noHorizMarginPaddingClass","paddingLeft","marginLeft","Part","theme","useTheme2","partClass","useMemo","lineHeight","typography","body","fontSize","getPartClass","isLast","items","Fragment","par","newParams","onParamChange","PartListSection","getNewPartOptions","onAddNewPart","onRemovePart","pars","paddingRightClass","OPTIONS","OrderByTimeSection","InputSection","isWide","runExploreQuery","FormatAsSection","format","uppercaseClass","textTransform","SectionLabel","isInitial","SectionFill","getPartParams","dynamicParamOptions","paramValues","defParam","makePartList","queryParts","qp","withTemplateVariableOptions","optionsPromise","SectionWrap","initialName","children","Editor","normalizeQuery","selectLists","dynamicSelectPartOptions","Map","item","getFieldKeysForMeasurement","sel","getTagKeysForMeasurementAndTags","groupByList","dynamicGroupByPartOptions","onAppliedChange","newQuery","getAllPolicies","measurementFilter","getAllMeasurementsForTags","m","Object","x","getNewSelectPartOptions","listIndex","newSel","changeSelectPart","model","addNewSelectPart","selectModel","tagKeys","getNewGroupByPartOptions","newGroupBy","changeGroupByPart","addNewGroupByPart","QueryEditorModeSwitcher","isRaw","isModalOpen","setModalOpen","confirmText","dismissText","onConfirm","onDismiss","CHEAT_SHEET_ITEMS","InfluxCheatSheet","InfluxStartPage","onClickExample","Select","Input","SecretFormField","LegacyForms","httpModes","versions","InfluxQL","ConfigEditor","maxSeries","updateDatasourcePluginResetOption","selected","onOptionsChange","copy","access","user","renderInflux2x","secureJsonFields","secureJsonData","organization","onUpdateDatasourceJsonDataOption","isConfigured","token","labelWidth","inputWidth","onReset","onResetToken","onUpdateDatasourceSecureJsonDataOption","defaultBucket","renderInflux1x","onUpdateDatasourceOption","onResetPassword","defaultValue","onUpdateDatasourceJsonDataOptionSelect","onVersionChanged","severity","showAccessOptions","dataSourceConfig","defaultUrl","event","setState","updateDatasourcePluginJsonDataOption","isFinite","VariableQueryEditor","onRefresh","InfluxAnnotationsQueryCtrl","plugin","DataSourcePlugin","setConfigEditor","setQueryEditor","display","flexGrow","setAnnotationQueryCtrl","setVariableQueryEditor","setQueryEditorHelp","ref"],"mappings":"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","file":"influxdbPlugin.9b94026935735f1cc824.js","sourcesContent":["'use strict';\n\n/* global setTimeout, clearTimeout */\n\nmodule.exports = function debounce(fn) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var lastCallAt = void 0;\n  var deferred = void 0;\n  var timer = void 0;\n  var pendingArgs = [];\n  return function debounced() {\n    var currentWait = getWait(wait);\n    var currentTime = new Date().getTime();\n\n    var isCold = !lastCallAt || currentTime - lastCallAt > currentWait;\n\n    lastCallAt = currentTime;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (isCold && options.leading) {\n      return options.accumulate ? Promise.resolve(fn.call(this, [args])).then(function (result) {\n        return result[0];\n      }) : Promise.resolve(fn.call.apply(fn, [this].concat(args)));\n    }\n\n    if (deferred) {\n      clearTimeout(timer);\n    } else {\n      deferred = defer();\n    }\n\n    pendingArgs.push(args);\n    timer = setTimeout(flush.bind(this), currentWait);\n\n    if (options.accumulate) {\n      var argsIndex = pendingArgs.length - 1;\n      return deferred.promise.then(function (results) {\n        return results[argsIndex];\n      });\n    }\n\n    return deferred.promise;\n  };\n\n  function flush() {\n    var thisDeferred = deferred;\n    clearTimeout(timer);\n\n    Promise.resolve(options.accumulate ? fn.call(this, pendingArgs) : fn.apply(this, pendingArgs[pendingArgs.length - 1])).then(thisDeferred.resolve, thisDeferred.reject);\n\n    pendingArgs = [];\n    deferred = null;\n  }\n};\n\nfunction getWait(wait) {\n  return typeof wait === 'function' ? wait() : wait;\n}\n\nfunction defer() {\n  var deferred = {};\n  deferred.promise = new Promise(function (resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\n//# sourceMappingURL=index.js.map","import { each, map, includes, flatten, keys } from 'lodash';\nimport TableModel from 'app/core/table_model';\nimport { FieldType, QueryResultMeta, TimeSeries, TableData } from '@grafana/data';\n\nexport default class InfluxSeries {\n  refId?: string;\n  series: any;\n  alias: any;\n  annotation: any;\n  meta?: QueryResultMeta;\n\n  constructor(options: { series: any; alias?: any; annotation?: any; meta?: QueryResultMeta; refId?: string }) {\n    this.series = options.series;\n    this.alias = options.alias;\n    this.annotation = options.annotation;\n    this.meta = options.meta;\n    this.refId = options.refId;\n  }\n\n  getTimeSeries(): TimeSeries[] {\n    const output: TimeSeries[] = [];\n    let i, j;\n\n    if (this.series.length === 0) {\n      return output;\n    }\n\n    each(this.series, (series) => {\n      const columns = series.columns.length;\n      const tags = map(series.tags, (value, key) => {\n        return key + ': ' + value;\n      });\n\n      for (j = 1; j < columns; j++) {\n        let seriesName = series.name;\n        const columnName = series.columns[j];\n        if (columnName !== 'value') {\n          seriesName = seriesName + '.' + columnName;\n        }\n\n        if (this.alias) {\n          seriesName = this._getSeriesName(series, j);\n        } else if (series.tags) {\n          seriesName = seriesName + ' {' + tags.join(', ') + '}';\n        }\n\n        const datapoints = [];\n        if (series.values) {\n          for (i = 0; i < series.values.length; i++) {\n            datapoints[i] = [series.values[i][j], series.values[i][0]];\n          }\n        }\n\n        output.push({\n          title: seriesName,\n          target: seriesName,\n          datapoints: datapoints,\n          tags: series.tags,\n          meta: this.meta,\n          refId: this.refId,\n        });\n      }\n    });\n\n    return output;\n  }\n\n  _getSeriesName(series: any, index: number) {\n    const regex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)\\]\\]/g;\n    const segments = series.name.split('.');\n\n    return this.alias.replace(regex, (match: any, g1: any, g2: any) => {\n      const group = g1 || g2;\n      const segIndex = parseInt(group, 10);\n\n      if (group === 'm' || group === 'measurement') {\n        return series.name;\n      }\n      if (group === 'col') {\n        return series.columns[index];\n      }\n      if (!isNaN(segIndex)) {\n        return segments[segIndex];\n      }\n      if (group.indexOf('tag_') !== 0) {\n        return match;\n      }\n\n      const tag = group.replace('tag_', '');\n      if (!series.tags) {\n        return match;\n      }\n      return series.tags[tag];\n    });\n  }\n\n  getAnnotations() {\n    const list: any[] = [];\n\n    each(this.series, (series) => {\n      let titleCol: any = null;\n      let timeCol: any = null;\n      let timeEndCol: any = null;\n      const tagsCol: any = [];\n      let textCol: any = null;\n\n      each(series.columns, (column, index) => {\n        if (column === 'time') {\n          timeCol = index;\n          return;\n        }\n        if (column === 'sequence_number') {\n          return;\n        }\n        if (column === this.annotation.titleColumn) {\n          titleCol = index;\n          return;\n        }\n        if (includes((this.annotation.tagsColumn || '').replace(' ', '').split(','), column)) {\n          tagsCol.push(index);\n          return;\n        }\n        if (column === this.annotation.textColumn) {\n          textCol = index;\n          return;\n        }\n        if (column === this.annotation.timeEndColumn) {\n          timeEndCol = index;\n          return;\n        }\n        // legacy case\n        if (!titleCol && textCol !== index) {\n          titleCol = index;\n        }\n      });\n\n      each(series.values, (value) => {\n        const data = {\n          annotation: this.annotation,\n          time: +new Date(value[timeCol]),\n          title: value[titleCol],\n          timeEnd: value[timeEndCol],\n          // Remove empty values, then split in different tags for comma separated values\n          tags: flatten(\n            tagsCol\n              .filter((t: any) => {\n                return value[t];\n              })\n              .map((t: any) => {\n                return value[t].split(',');\n              })\n          ),\n          text: value[textCol],\n        };\n\n        list.push(data);\n      });\n    });\n\n    return list;\n  }\n\n  getTable(): TableData {\n    const table = new TableModel();\n    let i, j;\n\n    table.refId = this.refId;\n    table.meta = this.meta;\n\n    if (this.series.length === 0) {\n      return table;\n    }\n\n    each(this.series, (series: any, seriesIndex: number) => {\n      if (seriesIndex === 0) {\n        j = 0;\n        // Check that the first column is indeed 'time'\n        if (series.columns[0] === 'time') {\n          // Push this now before the tags and with the right type\n          table.columns.push({ text: 'Time', type: FieldType.time });\n          j++;\n        }\n        each(keys(series.tags), (key) => {\n          table.columns.push({ text: key });\n        });\n        for (; j < series.columns.length; j++) {\n          table.columns.push({ text: series.columns[j] });\n        }\n      }\n\n      if (series.values) {\n        for (i = 0; i < series.values.length; i++) {\n          const values = series.values[i];\n          const reordered = [values[0]];\n          if (series.tags) {\n            for (const key in series.tags) {\n              if (series.tags.hasOwnProperty(key)) {\n                reordered.push(series.tags[key]);\n              }\n            }\n          }\n          for (j = 1; j < values.length; j++) {\n            reordered.push(values[j]);\n          }\n          table.rows.push(reordered);\n        }\n      }\n    });\n\n    return table;\n  }\n}\n","import { map, clone } from 'lodash';\nimport { QueryPartDef, QueryPart, functionRenderer, suffixRenderer } from 'app/core/components/query_part/query_part';\n\nconst index: any[] = [];\nconst categories: any = {\n  Aggregations: [],\n  Selectors: [],\n  Transformations: [],\n  Predictors: [],\n  Math: [],\n  Aliasing: [],\n  Fields: [],\n};\n\nfunction createPart(part: any): any {\n  const def = index[part.type];\n  if (!def) {\n    throw { message: 'Could not find query part ' + part.type };\n  }\n\n  return new QueryPart(part, def);\n}\n\nfunction register(options: any) {\n  index[options.type] = new QueryPartDef(options);\n  options.category.push(index[options.type]);\n}\n\nconst groupByTimeFunctions: any[] = [];\n\nfunction aliasRenderer(part: { params: string[] }, innerExpr: string) {\n  return innerExpr + ' AS ' + '\"' + part.params[0] + '\"';\n}\n\nfunction fieldRenderer(part: { params: string[] }, innerExpr: any) {\n  if (part.params[0] === '*') {\n    return '*';\n  }\n  return '\"' + part.params[0] + '\"';\n}\n\nfunction replaceAggregationAddStrategy(selectParts: any[], partModel: { def: { type: string } }) {\n  // look for existing aggregation\n  for (let i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Aggregations) {\n      if (part.def.type === partModel.def.type) {\n        return;\n      }\n      // count distinct is allowed\n      if (part.def.type === 'count' && partModel.def.type === 'distinct') {\n        break;\n      }\n      // remove next aggregation if distinct was replaced\n      if (part.def.type === 'distinct') {\n        const morePartsAvailable = selectParts.length >= i + 2;\n        if (partModel.def.type !== 'count' && morePartsAvailable) {\n          const nextPart = selectParts[i + 1];\n          if (nextPart.def.category === categories.Aggregations) {\n            selectParts.splice(i + 1, 1);\n          }\n        } else if (partModel.def.type === 'count') {\n          if (!morePartsAvailable || selectParts[i + 1].def.type !== 'count') {\n            selectParts.splice(i + 1, 0, partModel);\n          }\n          return;\n        }\n      }\n      selectParts[i] = partModel;\n      return;\n    }\n    if (part.def.category === categories.Selectors) {\n      selectParts[i] = partModel;\n      return;\n    }\n  }\n\n  selectParts.splice(1, 0, partModel);\n}\n\nfunction addTransformationStrategy(selectParts: any[], partModel: any) {\n  let i;\n  // look for index to add transformation\n  for (i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Math || part.def.category === categories.Aliasing) {\n      break;\n    }\n  }\n\n  selectParts.splice(i, 0, partModel);\n}\n\nfunction addMathStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is math, replace it\n    if (selectParts[partCount - 1].def.type === 'math') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n    // if next to last is math, replace it\n    if (partCount > 1 && selectParts[partCount - 2].def.type === 'math') {\n      selectParts[partCount - 2] = partModel;\n      return;\n    } else if (selectParts[partCount - 1].def.type === 'alias') {\n      // if last is alias add it before\n      selectParts.splice(partCount - 1, 0, partModel);\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addAliasStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is alias, replace it\n    if (selectParts[partCount - 1].def.type === 'alias') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addFieldStrategy(selectParts: any, partModel: any, query: { selectModels: any[][] }) {\n  // copy all parts\n  const parts = map(selectParts, (part: any) => {\n    return createPart({ type: part.def.type, params: clone(part.params) });\n  });\n\n  query.selectModels.push(parts);\n}\n\nregister({\n  type: 'field',\n  addStrategy: addFieldStrategy,\n  category: categories.Fields,\n  params: [{ type: 'field', dynamicLookup: true }],\n  defaultParams: ['value'],\n  renderer: fieldRenderer,\n});\n\n// Aggregations\nregister({\n  type: 'count',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'distinct',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'integral',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mean',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'median',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mode',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'sum',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\n// transformations\n\nregister({\n  type: 'derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'spread',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'moving_average',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [{ name: 'window', type: 'int', options: [5, 10, 20, 30, 40] }],\n  defaultParams: [10],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'cumulative_sum',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'stddev',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'time',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'interval',\n      type: 'time',\n      options: ['$__interval', '1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['$__interval'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'fill',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'fill',\n      type: 'string',\n      options: ['none', 'null', '0', 'previous', 'linear'],\n    },\n  ],\n  defaultParams: ['null'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'elapsed',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\n// predictions\nregister({\n  type: 'holt_winters',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'holt_winters_with_fit',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\n// Selectors\nregister({\n  type: 'bottom',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'first',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'last',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'max',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'min',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'percentile',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'nth', type: 'int' }],\n  defaultParams: [95],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'top',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'tag',\n  category: groupByTimeFunctions,\n  params: [{ name: 'tag', type: 'string', dynamicLookup: true }],\n  defaultParams: ['tag'],\n  renderer: fieldRenderer,\n});\n\nregister({\n  type: 'math',\n  addStrategy: addMathStrategy,\n  category: categories.Math,\n  params: [{ name: 'expr', type: 'string' }],\n  defaultParams: [' / 100'],\n  renderer: suffixRenderer,\n});\n\nregister({\n  type: 'alias',\n  addStrategy: addAliasStrategy,\n  category: categories.Aliasing,\n  params: [{ name: 'name', type: 'string', quote: 'double' }],\n  defaultParams: ['alias'],\n  renderMode: 'suffix',\n  renderer: aliasRenderer,\n});\n\nexport default {\n  create: createPart,\n  getCategories: () => {\n    return categories;\n  },\n  replaceAggregationAdd: replaceAggregationAddStrategy,\n};\n","import { map, find, filter, indexOf } from 'lodash';\nimport queryPart from './query_part';\nimport kbn from 'app/core/utils/kbn';\nimport { InfluxQuery, InfluxQueryTag } from './types';\nimport { ScopedVars } from '@grafana/data';\nimport { TemplateSrv } from '@grafana/runtime';\n\nexport default class InfluxQueryModel {\n  target: InfluxQuery;\n  selectModels: any[] = [];\n  queryBuilder: any;\n  groupByParts: any;\n  templateSrv: any;\n  scopedVars: any;\n  refId?: string;\n\n  /** @ngInject */\n  constructor(target: InfluxQuery, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n\n    target.policy = target.policy || 'default';\n    target.resultFormat = target.resultFormat || 'time_series';\n    target.orderByTime = target.orderByTime || 'ASC';\n    target.tags = target.tags || [];\n    target.groupBy = target.groupBy || [\n      { type: 'time', params: ['$__interval'] },\n      { type: 'fill', params: ['null'] },\n    ];\n    target.select = target.select || [\n      [\n        { type: 'field', params: ['value'] },\n        { type: 'mean', params: [] },\n      ],\n    ];\n\n    this.updateProjection();\n  }\n\n  updateProjection() {\n    this.selectModels = map(this.target.select, (parts: any) => {\n      return map(parts, queryPart.create);\n    });\n    this.groupByParts = map(this.target.groupBy, queryPart.create);\n  }\n\n  updatePersistedParts() {\n    this.target.select = map(this.selectModels, (selectParts) => {\n      return map(selectParts, (part: any) => {\n        return { type: part.def.type, params: part.params };\n      });\n    });\n  }\n\n  hasGroupByTime() {\n    return find(this.target.groupBy, (g: any) => g.type === 'time');\n  }\n\n  hasFill() {\n    return find(this.target.groupBy, (g: any) => g.type === 'fill');\n  }\n\n  addGroupBy(value: string) {\n    let stringParts = value.match(/^(\\w+)\\((.*)\\)$/);\n\n    if (!stringParts || !this.target.groupBy) {\n      return;\n    }\n\n    const typePart = stringParts[1];\n    const arg = stringParts[2];\n    const partModel = queryPart.create({ type: typePart, params: [arg] });\n    const partCount = this.target.groupBy.length;\n\n    if (partCount === 0) {\n      this.target.groupBy.push(partModel.part);\n    } else if (typePart === 'time') {\n      this.target.groupBy.splice(0, 0, partModel.part);\n    } else if (typePart === 'tag') {\n      if (this.target.groupBy[partCount - 1].type === 'fill') {\n        this.target.groupBy.splice(partCount - 1, 0, partModel.part);\n      } else {\n        this.target.groupBy.push(partModel.part);\n      }\n    } else {\n      this.target.groupBy.push(partModel.part);\n    }\n\n    this.updateProjection();\n  }\n\n  removeGroupByPart(part: { def: { type: string } }, index: number) {\n    const categories = queryPart.getCategories();\n\n    if (part.def.type === 'time') {\n      // remove fill\n      this.target.groupBy = filter(this.target.groupBy, (g: any) => g.type !== 'fill');\n      // remove aggregations\n      this.target.select = map(this.target.select, (s: any) => {\n        return filter(s, (part: any) => {\n          const partModel = queryPart.create(part);\n          if (partModel.def.category === categories.Aggregations) {\n            return false;\n          }\n          if (partModel.def.category === categories.Selectors) {\n            return false;\n          }\n          return true;\n        });\n      });\n    }\n\n    this.target.groupBy!.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelect(index: number) {\n    this.target.select!.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelectPart(selectParts: any[], part: any) {\n    // if we remove the field remove the whole statement\n    if (part.def.type === 'field') {\n      if (this.selectModels.length > 1) {\n        const modelsIndex = indexOf(this.selectModels, selectParts);\n        this.selectModels.splice(modelsIndex, 1);\n      }\n    } else {\n      const partIndex = indexOf(selectParts, part);\n      selectParts.splice(partIndex, 1);\n    }\n\n    this.updatePersistedParts();\n  }\n\n  addSelectPart(selectParts: any[], type: string) {\n    const partModel = queryPart.create({ type: type });\n    partModel.def.addStrategy(selectParts, partModel, this);\n    this.updatePersistedParts();\n  }\n\n  private renderTagCondition(tag: InfluxQueryTag, index: number, interpolate?: boolean) {\n    let str = '';\n    let operator = tag.operator;\n    let value = tag.value;\n    if (index > 0) {\n      str = (tag.condition || 'AND') + ' ';\n    }\n\n    if (!operator) {\n      if (/^\\/.*\\/$/.test(value)) {\n        operator = '=~';\n      } else {\n        operator = '=';\n      }\n    }\n\n    // quote value unless regex\n    if (operator !== '=~' && operator !== '!~') {\n      if (interpolate) {\n        value = this.templateSrv.replace(value, this.scopedVars);\n      }\n      if (operator !== '>' && operator !== '<') {\n        value = \"'\" + value.replace(/\\\\/g, '\\\\\\\\').replace(/\\'/g, \"\\\\'\") + \"'\";\n      }\n    } else if (interpolate) {\n      value = this.templateSrv.replace(value, this.scopedVars, 'regex');\n    }\n\n    return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n  }\n\n  getMeasurementAndPolicy(interpolate: any) {\n    let policy = this.target.policy;\n    let measurement = this.target.measurement || 'measurement';\n\n    if (!measurement.match('^/.*/$')) {\n      measurement = '\"' + measurement + '\"';\n    } else if (interpolate) {\n      measurement = this.templateSrv.replace(measurement, this.scopedVars, 'regex');\n    }\n\n    if (policy !== 'default') {\n      policy = '\"' + this.target.policy + '\".';\n    } else {\n      policy = '';\n    }\n\n    return policy + measurement;\n  }\n\n  interpolateQueryStr(value: any[], variable: { multi: any; includeAll: any }, defaultFormatFn: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return kbn.regexEscape(value);\n    }\n\n    const escapedValues = map(value, kbn.regexEscape);\n    return '(' + escapedValues.join('|') + ')';\n  }\n\n  render(interpolate?: boolean) {\n    const target = this.target;\n\n    if (target.rawQuery) {\n      if (interpolate) {\n        return this.templateSrv.replace(target.query, this.scopedVars, this.interpolateQueryStr);\n      } else {\n        return target.query;\n      }\n    }\n\n    let query = 'SELECT ';\n    let i, y;\n    for (i = 0; i < this.selectModels.length; i++) {\n      const parts = this.selectModels[i];\n      let selectText = '';\n      for (y = 0; y < parts.length; y++) {\n        const part = parts[y];\n        selectText = part.render(selectText);\n      }\n\n      if (i > 0) {\n        query += ', ';\n      }\n      query += selectText;\n    }\n\n    query += ' FROM ' + this.getMeasurementAndPolicy(interpolate) + ' WHERE ';\n    const conditions = map(target.tags, (tag, index) => {\n      return this.renderTagCondition(tag, index, interpolate);\n    });\n\n    if (conditions.length > 0) {\n      query += '(' + conditions.join(' ') + ') AND ';\n    }\n\n    query += '$timeFilter';\n\n    let groupBySection = '';\n    for (i = 0; i < this.groupByParts.length; i++) {\n      const part = this.groupByParts[i];\n      if (i > 0) {\n        // for some reason fill has no separator\n        groupBySection += part.def.type === 'fill' ? ' ' : ', ';\n      }\n      groupBySection += part.render('');\n    }\n\n    if (groupBySection.length) {\n      query += ' GROUP BY ' + groupBySection;\n    }\n\n    if (target.fill) {\n      query += ' fill(' + target.fill + ')';\n    }\n\n    if (target.orderByTime === 'DESC') {\n      query += ' ORDER BY time DESC';\n    }\n\n    if (target.limit) {\n      query += ' LIMIT ' + target.limit;\n    }\n\n    if (target.slimit) {\n      query += ' SLIMIT ' + target.slimit;\n    }\n\n    if (target.tz) {\n      query += \" tz('\" + target.tz + \"')\";\n    }\n\n    return query;\n  }\n\n  renderAdhocFilters(filters: any[]) {\n    const conditions = map(filters, (tag, index) => {\n      return this.renderTagCondition(tag, index, true);\n    });\n    return conditions.join(' ');\n  }\n}\n","import { each, isArray } from 'lodash';\n\nexport default class ResponseParser {\n  parse(query: string, results: { results: any }) {\n    if (!results?.results || results.results.length === 0) {\n      return [];\n    }\n\n    const influxResults = results.results[0];\n    if (!influxResults.series) {\n      return [];\n    }\n\n    const normalizedQuery = query.toLowerCase();\n    const isValueFirst =\n      normalizedQuery.indexOf('show field keys') >= 0 || normalizedQuery.indexOf('show retention policies') >= 0;\n\n    const res = new Set<string>();\n    each(influxResults.series, (serie) => {\n      each(serie.values, (value) => {\n        if (isArray(value)) {\n          // In general, there are 2 possible shapes for the returned value.\n          // The first one is a two-element array,\n          // where the first element is somewhat a metadata value:\n          // the tag name for SHOW TAG VALUES queries,\n          // the time field for SELECT queries, etc.\n          // The second shape is an one-element array,\n          // that is containing an immediate value.\n          // For example, SHOW FIELD KEYS queries return such shape.\n          // Note, pre-0.11 versions return\n          // the second shape for SHOW TAG VALUES queries\n          // (while the newer versions—first).\n\n          if (isValueFirst) {\n            addUnique(res, value[0]);\n          } else if (value[1] !== undefined) {\n            addUnique(res, value[1]);\n          } else {\n            addUnique(res, value[0]);\n          }\n        } else {\n          addUnique(res, value);\n        }\n      });\n    });\n\n    // NOTE: it is important to keep the order of items in the parsed output\n    // the same as it was in the influxdb-response.\n    // we use a `Set` to collect the unique-results, and `Set` iteration\n    // order is insertion-order, so this should be ok.\n    return Array.from(res).map((v) => ({ text: v }));\n  }\n}\n\nfunction addUnique(s: Set<string>, value: string | number) {\n  s.add(value.toString());\n}\n","import { reduce } from 'lodash';\nimport kbn from 'app/core/utils/kbn';\n\nfunction renderTagCondition(tag: { operator: any; value: string; condition: any; key: string }, index: number) {\n  let str = '';\n  let operator = tag.operator;\n  let value = tag.value;\n  if (index > 0) {\n    str = (tag.condition || 'AND') + ' ';\n  }\n\n  if (!operator) {\n    if (/^\\/.*\\/$/.test(tag.value)) {\n      operator = '=~';\n    } else {\n      operator = '=';\n    }\n  }\n\n  // quote value unless regex or number, or if empty-string\n  if (value === '' || (operator !== '=~' && operator !== '!~' && isNaN(+value))) {\n    value = \"'\" + value + \"'\";\n  }\n\n  return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n}\n\nexport class InfluxQueryBuilder {\n  constructor(private target: { measurement: any; tags: any; policy?: any }, private database?: string) {}\n\n  buildExploreQuery(type: string, withKey?: string, withMeasurementFilter?: string): string {\n    let query = '';\n    let measurement;\n    let policy;\n\n    if (type === 'TAG_KEYS') {\n      query = 'SHOW TAG KEYS';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'TAG_VALUES') {\n      query = 'SHOW TAG VALUES';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'MEASUREMENTS') {\n      query = 'SHOW MEASUREMENTS';\n      if (withMeasurementFilter) {\n        // we do a case-insensitive regex-based lookup\n        query += ' WITH MEASUREMENT =~ /(?i)' + kbn.regexEscape(withMeasurementFilter) + '/';\n      }\n    } else if (type === 'FIELDS') {\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n\n      if (!measurement.match('^/.*/')) {\n        measurement = '\"' + measurement + '\"';\n\n        if (policy && policy !== 'default') {\n          policy = '\"' + policy + '\"';\n          measurement = policy + '.' + measurement;\n        }\n      }\n\n      return 'SHOW FIELD KEYS FROM ' + measurement;\n    } else if (type === 'RETENTION POLICIES') {\n      query = 'SHOW RETENTION POLICIES on \"' + this.database + '\"';\n      return query;\n    }\n\n    if (measurement) {\n      if (!measurement.match('^/.*/') && !measurement.match(/^merge\\(.*\\)/)) {\n        measurement = '\"' + measurement + '\"';\n      }\n\n      if (policy && policy !== 'default') {\n        policy = '\"' + policy + '\"';\n        measurement = policy + '.' + measurement;\n      }\n\n      query += ' FROM ' + measurement;\n    }\n\n    if (withKey) {\n      query += ' WITH KEY = \"' + withKey + '\"';\n    }\n\n    if (this.target.tags && this.target.tags.length > 0) {\n      const whereConditions = reduce(\n        this.target.tags,\n        (memo, tag) => {\n          // do not add a condition for the key we want to explore for\n          if (tag.key === withKey) {\n            return memo;\n          }\n\n          // value operators not supported in these types of queries\n          if (tag.operator === '>' || tag.operator === '<') {\n            return memo;\n          }\n\n          memo.push(renderTagCondition(tag, memo.length));\n          return memo;\n        },\n        [] as string[]\n      );\n\n      if (whereConditions.length > 0) {\n        query += ' WHERE ' + whereConditions.join(' ');\n      }\n    }\n\n    if (type === 'MEASUREMENTS') {\n      query += ' LIMIT 100';\n      //Solve issue #2524 by limiting the number of measurements returned\n      //LIMIT must be after WITH MEASUREMENT and WHERE clauses\n      //This also could be used for TAG KEYS and TAG VALUES, if desired\n    }\n\n    return query;\n  }\n}\n","import { DataQuery, DataSourceJsonData } from '@grafana/data';\n\nexport enum InfluxVersion {\n  InfluxQL = 'InfluxQL',\n  Flux = 'Flux',\n}\n\nexport interface InfluxOptions extends DataSourceJsonData {\n  version?: InfluxVersion;\n\n  timeInterval: string;\n  httpMode: string;\n\n  // With Flux\n  organization?: string;\n  defaultBucket?: string;\n  maxSeries?: number;\n}\n\nexport interface InfluxSecureJsonData {\n  // For Flux\n  token?: string;\n\n  // In 1x a different password can be sent than then HTTP auth\n  password?: string;\n}\n\nexport interface InfluxQueryPart {\n  type: string;\n  params?: Array<string | number>;\n  // FIXME: `interval` does not seem to be used.\n  // check all the influxdb parts (query-generation etc.),\n  // if it is really so, and if yes, remove it\n  interval?: string;\n}\n\nexport interface InfluxQueryTag {\n  key: string;\n  operator?: string;\n  condition?: string;\n  value: string;\n}\n\nexport type ResultFormat = 'time_series' | 'table' | 'logs';\n\nexport interface InfluxQuery extends DataQuery {\n  policy?: string;\n  measurement?: string;\n  resultFormat?: ResultFormat;\n  orderByTime?: string;\n  tags?: InfluxQueryTag[];\n  groupBy?: InfluxQueryPart[];\n  select?: InfluxQueryPart[][];\n  limit?: string | number;\n  slimit?: string | number;\n  tz?: string;\n  // NOTE: `fill` is not used in the query-editor anymore, and is removed\n  // if any change happens in the query-editor. the query-generation still\n  // supports it for now.\n  fill?: string;\n  rawQuery?: boolean;\n  query?: string;\n  alias?: string;\n}\n","import React, { PureComponent } from 'react';\nimport { InfluxQuery } from '../types';\nimport { SelectableValue } from '@grafana/data';\nimport { cx, css } from '@emotion/css';\nimport {\n  InlineFormLabel,\n  LinkButton,\n  Segment,\n  CodeEditor,\n  MonacoEditor,\n  CodeEditorSuggestionItem,\n  CodeEditorSuggestionItemKind,\n} from '@grafana/ui';\nimport { getTemplateSrv } from '@grafana/runtime';\nimport InfluxDatasource from '../datasource';\n\ntype Props = {\n  onChange: (query: InfluxQuery) => void;\n  onRunQuery: () => void;\n  query: InfluxQuery;\n  // `datasource` is not used internally, but this component is used at some places\n  // directly, where the `datasource` prop has to exist. later, when the whole\n  // query-editor gets converted to react we can stop using this component directly\n  // and then we can probably remove the datasource attribute.\n  datasource: InfluxDatasource;\n};\n\nconst samples: Array<SelectableValue<string>> = [\n  { label: 'Show buckets', description: 'List the available buckets (table)', value: 'buckets()' },\n  {\n    label: 'Simple query',\n    description: 'filter by measurement and field',\n    value: `from(bucket: \"db/rp\")\n  |> range(start: v.timeRangeStart, stop:v.timeRangeStop)\n  |> filter(fn: (r) =>\n    r._measurement == \"example-measurement\" and\n    r._field == \"example-field\"\n  )`,\n  },\n  {\n    label: 'Grouped Query',\n    description: 'Group by (min/max/sum/median)',\n    value: `// v.windowPeriod is a variable referring to the current optimized window period (currently: $interval)\nfrom(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"measurement1\" or r[\"_measurement\"] =~ /^.*?regex.*$/)\n  |> filter(fn: (r) => r[\"_field\"] == \"field2\" or r[\"_field\"] =~ /^.*?regex.*$/)\n  |> aggregateWindow(every: v.windowPeriod, fn: mean|median|max|count|derivative|sum)\n  |> yield(name: \"some-name\")`,\n  },\n  {\n    label: 'Filter by value',\n    description: 'Results between a min/max',\n    value: `// v.bucket, v.timeRangeStart, and v.timeRange stop are all variables supported by the flux plugin and influxdb\nfrom(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_value\"] >= 10 and r[\"_value\"] <= 20)`,\n  },\n  {\n    label: 'Schema Exploration: (measurements)',\n    description: 'Get a list of measurement using flux',\n    value: `import \"influxdata/influxdb/v1\"\nv1.measurements(bucket: v.bucket)`,\n  },\n  {\n    label: 'Schema Exploration: (fields)',\n    description: 'Return every possible key in a single table',\n    value: `from(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop:v.timeRangeStop)\n  |> keys()\n  |> keep(columns: [\"_value\"])\n  |> group()\n  |> distinct()`,\n  },\n  {\n    label: 'Schema Exploration: (tag keys)',\n    description: 'Get a list of tag keys using flux',\n    value: `import \"influxdata/influxdb/v1\"\nv1.tagKeys(bucket: v.bucket)`,\n  },\n  {\n    label: 'Schema Exploration: (tag values)',\n    description: 'Get a list of tag values using flux',\n    value: `import \"influxdata/influxdb/v1\"\nv1.tagValues(\n    bucket: v.bucket,\n    tag: \"host\",\n    predicate: (r) => true,\n    start: -1d\n)`,\n  },\n];\n\nexport class FluxQueryEditor extends PureComponent<Props> {\n  onFluxQueryChange = (query: string) => {\n    this.props.onChange({ ...this.props.query, query });\n    this.props.onRunQuery();\n  };\n\n  onSampleChange = (val: SelectableValue<string>) => {\n    this.props.onChange({\n      ...this.props.query,\n      query: val.value!,\n    });\n\n    // Angular HACK: Since the target does not actually change!\n    this.forceUpdate();\n    this.props.onRunQuery();\n  };\n\n  getSuggestions = (): CodeEditorSuggestionItem[] => {\n    const sugs: CodeEditorSuggestionItem[] = [\n      {\n        label: 'v.timeRangeStart',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'The start time',\n      },\n      {\n        label: 'v.timeRangeStop',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'The stop time',\n      },\n      {\n        label: 'v.windowPeriod',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'based on max data points',\n      },\n      {\n        label: 'v.defaultBucket',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'bucket configured in the datsource',\n      },\n      {\n        label: 'v.organization',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'org configured for the datsource',\n      },\n    ];\n\n    const templateSrv = getTemplateSrv();\n    templateSrv.getVariables().forEach((variable) => {\n      const label = '${' + variable.name + '}';\n      let val = templateSrv.replace(label);\n      if (val === label) {\n        val = '';\n      }\n      sugs.push({\n        label,\n        kind: CodeEditorSuggestionItemKind.Text,\n        detail: `(Template Variable) ${val}`,\n      });\n    });\n\n    return sugs;\n  };\n\n  // For some reason in angular, when this component gets re-mounted, the width\n  // is not set properly.  This forces the layout shortly after mount so that it\n  // displays OK.  Note: this is not an issue when used directly in react\n  editorDidMountCallbackHack = (editor: MonacoEditor) => {\n    setTimeout(() => editor.layout(), 100);\n  };\n\n  render() {\n    const { query } = this.props;\n\n    const helpTooltip = (\n      <div>\n        Type: <i>ctrl+space</i> to show template variable suggestions <br />\n        Many queries can be copied from chronograph\n      </div>\n    );\n\n    return (\n      <>\n        <CodeEditor\n          height={'200px'}\n          language=\"sql\"\n          value={query.query || ''}\n          onBlur={this.onFluxQueryChange}\n          onSave={this.onFluxQueryChange}\n          showMiniMap={false}\n          showLineNumbers={true}\n          getSuggestions={this.getSuggestions}\n          onEditorDidMount={this.editorDidMountCallbackHack}\n        />\n        <div\n          className={cx(\n            'gf-form-inline',\n            css`\n              margin-top: 6px;\n            `\n          )}\n        >\n          <LinkButton\n            icon=\"external-link-alt\"\n            variant=\"secondary\"\n            target=\"blank\"\n            href=\"https://docs.influxdata.com/influxdb/latest/query-data/get-started/\"\n          >\n            Flux language syntax\n          </LinkButton>\n          <Segment options={samples} value=\"Sample Query\" onChange={this.onSampleChange} />\n          <div className=\"gf-form gf-form--grow\">\n            <div className=\"gf-form-label gf-form-label--grow\"></div>\n          </div>\n          <InlineFormLabel width={5} tooltip={helpTooltip}>\n            Help\n          </InlineFormLabel>\n        </div>\n      </>\n    );\n  }\n}\n","import { cloneDeep } from 'lodash';\nimport InfluxQueryModel from './influx_query_model';\nimport { InfluxQuery } from './types';\n\n// FIXME: these functions are a beginning of a refactoring of influx_query_model.ts\n// into a simpler approach with full typescript types.\n// later we should be able to migrate the unit-tests\n// that relate to these functions here, and then perhaps even move the implementation\n// to this place\n\nexport function buildRawQuery(query: InfluxQuery): string {\n  const queryCopy = cloneDeep(query); // the query-model mutates the query\n  const model = new InfluxQueryModel(queryCopy);\n  return model.render(false);\n}\n\nexport function normalizeQuery(query: InfluxQuery): InfluxQuery {\n  // we return the original query if there is no need to update it\n  if (\n    query.policy !== undefined &&\n    query.resultFormat !== undefined &&\n    query.orderByTime !== undefined &&\n    query.tags !== undefined &&\n    query.groupBy !== undefined &&\n    query.select !== undefined\n  ) {\n    return query;\n  }\n\n  // FIXME: we should move the whole normalizeQuery logic here,\n  // and then have influxQueryModel call this function,\n  // to concentrate the whole logic here\n\n  const queryCopy = cloneDeep(query); // the query-model mutates the query\n  return new InfluxQueryModel(queryCopy).target;\n}\n\nexport function addNewSelectPart(query: InfluxQuery, type: string, index: number): InfluxQuery {\n  const queryCopy = cloneDeep(query); // the query-model mutates the query\n  const model = new InfluxQueryModel(queryCopy);\n  model.addSelectPart(model.selectModels[index], type);\n  return model.target;\n}\n\nexport function removeSelectPart(query: InfluxQuery, partIndex: number, index: number): InfluxQuery {\n  const queryCopy = cloneDeep(query); // the query-model mutates the query\n  const model = new InfluxQueryModel(queryCopy);\n  const selectModel = model.selectModels[index];\n  model.removeSelectPart(selectModel, selectModel[partIndex]);\n  return model.target;\n}\n\nexport function changeSelectPart(\n  query: InfluxQuery,\n  listIndex: number,\n  partIndex: number,\n  newParams: string[]\n): InfluxQuery {\n  // we need to make shallow copy of `query.select` down to `query.select[listIndex][partIndex]`\n  const newSel = [...(query.select ?? [])];\n  newSel[listIndex] = [...newSel[listIndex]];\n  newSel[listIndex][partIndex] = {\n    ...newSel[listIndex][partIndex],\n    params: newParams,\n  };\n  return { ...query, select: newSel };\n}\n\nexport function addNewGroupByPart(query: InfluxQuery, type: string): InfluxQuery {\n  const queryCopy = cloneDeep(query); // the query-model mutates the query\n  const model = new InfluxQueryModel(queryCopy);\n  model.addGroupBy(type);\n  return model.target;\n}\n\nexport function removeGroupByPart(query: InfluxQuery, partIndex: number): InfluxQuery {\n  const queryCopy = cloneDeep(query); // the query-model mutates the query\n  const model = new InfluxQueryModel(queryCopy);\n  model.removeGroupByPart(model.groupByParts[partIndex], partIndex);\n  return model.target;\n}\n\nexport function changeGroupByPart(query: InfluxQuery, partIndex: number, newParams: string[]): InfluxQuery {\n  // we need to make shallow copy of `query.groupBy` down to `query.groupBy[partIndex]`\n  const newGroupBy = [...(query.groupBy ?? [])];\n  newGroupBy[partIndex] = {\n    ...newGroupBy[partIndex],\n    params: newParams,\n  };\n  return { ...query, groupBy: newGroupBy };\n}\n","import { cloneDeep, map as _map, reduce, get, has, extend, omit, pick, isString } from 'lodash';\n\nimport {\n  dateMath,\n  DataSourceInstanceSettings,\n  ScopedVars,\n  DataQueryRequest,\n  DataQueryResponse,\n  dateTime,\n  LoadingState,\n  QueryResultMeta,\n  MetricFindValue,\n  AnnotationQueryRequest,\n  AnnotationEvent,\n  DataQueryError,\n  DataFrame,\n  TimeSeries,\n  TIME_SERIES_TIME_FIELD_NAME,\n  TIME_SERIES_VALUE_FIELD_NAME,\n  FieldType,\n  ArrayVector,\n} from '@grafana/data';\nimport { v4 as uuidv4 } from 'uuid';\nimport InfluxSeries from './influx_series';\nimport InfluxQueryModel from './influx_query_model';\nimport ResponseParser from './response_parser';\nimport { InfluxQueryBuilder } from './query_builder';\nimport { InfluxQuery, InfluxOptions, InfluxVersion } from './types';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport { getBackendSrv, DataSourceWithBackend, frameToMetricFindValue } from '@grafana/runtime';\nimport { Observable, throwError, of } from 'rxjs';\nimport { FluxQueryEditor } from './components/FluxQueryEditor';\nimport { catchError, map } from 'rxjs/operators';\nimport { buildRawQuery } from './queryUtils';\n\n// we detect the field type based on the value-array\nfunction getFieldType(values: unknown[]): FieldType {\n  // the values-array may contain a lot of nulls.\n  // we need the first not-null item\n  const firstNotNull = values.find((v) => v !== null);\n\n  if (firstNotNull === undefined) {\n    // we could not find any not-null values\n    return FieldType.number;\n  }\n\n  const valueType = typeof firstNotNull;\n\n  switch (valueType) {\n    case 'string':\n      return FieldType.string;\n    case 'boolean':\n      return FieldType.boolean;\n    case 'number':\n      return FieldType.number;\n    default:\n      // this should never happen, influxql values\n      // can only be numbers, strings and booleans.\n      throw new Error(`InfluxQL: invalid value type ${valueType}`);\n  }\n}\n\n// this conversion function is specialized to work with the timeseries\n// data returned by InfluxDatasource.getTimeSeries()\nfunction timeSeriesToDataFrame(timeSeries: TimeSeries): DataFrame {\n  const times: number[] = [];\n  const values: unknown[] = [];\n\n  // the data we process here is not correctly typed.\n  // the typescript types say every data-point is number|null,\n  // but in fact it can be string or boolean too.\n\n  const points = timeSeries.datapoints;\n  for (const point of points) {\n    values.push(point[0]);\n    times.push(point[1] as number);\n  }\n\n  const timeField = {\n    name: TIME_SERIES_TIME_FIELD_NAME,\n    type: FieldType.time,\n    config: {},\n    values: new ArrayVector<number>(times),\n  };\n\n  const valueField = {\n    name: TIME_SERIES_VALUE_FIELD_NAME,\n    type: getFieldType(values),\n    config: {\n      displayNameFromDS: timeSeries.title,\n    },\n    values: new ArrayVector<unknown>(values),\n    labels: timeSeries.tags,\n  };\n\n  const fields = [timeField, valueField];\n\n  return {\n    name: timeSeries.target,\n    refId: timeSeries.refId,\n    meta: timeSeries.meta,\n    fields,\n    length: values.length,\n  };\n}\n\nexport default class InfluxDatasource extends DataSourceWithBackend<InfluxQuery, InfluxOptions> {\n  type: string;\n  urls: string[];\n  username: string;\n  password: string;\n  name: string;\n  database: any;\n  basicAuth: any;\n  withCredentials: any;\n  interval: any;\n  responseParser: any;\n  httpMode: string;\n  isFlux: boolean;\n\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<InfluxOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv()\n  ) {\n    super(instanceSettings);\n\n    this.type = 'influxdb';\n    this.urls = (instanceSettings.url ?? '').split(',').map((url) => {\n      return url.trim();\n    });\n\n    this.username = instanceSettings.username ?? '';\n    this.password = instanceSettings.password ?? '';\n    this.name = instanceSettings.name;\n    this.database = instanceSettings.database;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    const settingsData = instanceSettings.jsonData || ({} as InfluxOptions);\n    this.interval = settingsData.timeInterval;\n    this.httpMode = settingsData.httpMode || 'GET';\n    this.responseParser = new ResponseParser();\n    this.isFlux = settingsData.version === InfluxVersion.Flux;\n\n    if (this.isFlux) {\n      // When flux, use an annotation processor rather than the `annotationQuery` lifecycle\n      this.annotations = {\n        QueryEditor: FluxQueryEditor,\n      };\n    }\n  }\n\n  query(request: DataQueryRequest<InfluxQuery>): Observable<DataQueryResponse> {\n    if (this.isFlux) {\n      // for not-flux queries we call `this.classicQuery`, and that\n      // handles the is-hidden situation.\n      // for the flux-case, we do the filtering here\n      const filteredRequest = {\n        ...request,\n        targets: request.targets.filter((t) => t.hide !== true),\n      };\n      return super.query(filteredRequest);\n    }\n\n    // Fallback to classic query support\n    return this.classicQuery(request);\n  }\n\n  getQueryDisplayText(query: InfluxQuery) {\n    if (this.isFlux) {\n      return query.query;\n    }\n    return new InfluxQueryModel(query).render(false);\n  }\n\n  /**\n   * Returns false if the query should be skipped\n   */\n  filterQuery(query: InfluxQuery): boolean {\n    if (this.isFlux) {\n      return !!query.query;\n    }\n    return true;\n  }\n\n  /**\n   * Only applied on flux queries\n   */\n  applyTemplateVariables(query: InfluxQuery, scopedVars: ScopedVars): Record<string, any> {\n    return {\n      ...query,\n      query: this.templateSrv.replace(query.query ?? '', scopedVars), // The raw query text\n    };\n  }\n\n  /**\n   * The unchanged pre 7.1 query implementation\n   */\n  classicQuery(options: any): Observable<DataQueryResponse> {\n    let timeFilter = this.getTimeFilter(options);\n    const scopedVars = options.scopedVars;\n    const targets = cloneDeep(options.targets);\n    const queryTargets: any[] = [];\n\n    let i, y;\n\n    let allQueries = _map(targets, (target) => {\n      if (target.hide) {\n        return '';\n      }\n\n      queryTargets.push(target);\n\n      // backward compatibility\n      scopedVars.interval = scopedVars.__interval;\n\n      return new InfluxQueryModel(target, this.templateSrv, scopedVars).render(true);\n    }).reduce((acc, current) => {\n      if (current !== '') {\n        acc += ';' + current;\n      }\n      return acc;\n    });\n\n    if (allQueries === '') {\n      return of({ data: [] });\n    }\n\n    // add global adhoc filters to timeFilter\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    if (adhocFilters.length > 0) {\n      const tmpQuery = new InfluxQueryModel({ refId: 'A' }, this.templateSrv, scopedVars);\n      timeFilter += ' AND ' + tmpQuery.renderAdhocFilters(adhocFilters);\n    }\n\n    // replace grafana variables\n    scopedVars.timeFilter = { value: timeFilter };\n\n    // replace templated variables\n    allQueries = this.templateSrv.replace(allQueries, scopedVars);\n\n    return this._seriesQuery(allQueries, options).pipe(\n      map((data: any) => {\n        if (!data || !data.results) {\n          return { data: [] };\n        }\n\n        const seriesList = [];\n        for (i = 0; i < data.results.length; i++) {\n          const result = data.results[i];\n          if (!result || !result.series) {\n            continue;\n          }\n\n          const target = queryTargets[i];\n          let alias = target.alias;\n          if (alias) {\n            alias = this.templateSrv.replace(target.alias, options.scopedVars);\n          }\n\n          const meta: QueryResultMeta = {\n            executedQueryString: data.executedQueryString,\n          };\n\n          const influxSeries = new InfluxSeries({\n            refId: target.refId,\n            series: data.results[i].series,\n            alias: alias,\n            meta,\n          });\n\n          switch (target.resultFormat) {\n            case 'logs':\n              meta.preferredVisualisationType = 'logs';\n            case 'table': {\n              seriesList.push(influxSeries.getTable());\n              break;\n            }\n            default: {\n              const timeSeries = influxSeries.getTimeSeries();\n              for (y = 0; y < timeSeries.length; y++) {\n                seriesList.push(timeSeriesToDataFrame(timeSeries[y]));\n              }\n              break;\n            }\n          }\n        }\n\n        return { data: seriesList };\n      })\n    );\n  }\n\n  async annotationQuery(options: AnnotationQueryRequest<any>): Promise<AnnotationEvent[]> {\n    if (this.isFlux) {\n      return Promise.reject({\n        message: 'Flux requires the standard annotation query',\n      });\n    }\n\n    // InfluxQL puts a query string on the annotation\n    if (!options.annotation.query) {\n      return Promise.reject({\n        message: 'Query missing in annotation definition',\n      });\n    }\n\n    const timeFilter = this.getTimeFilter({ rangeRaw: options.rangeRaw, timezone: options.dashboard.timezone });\n    let query = options.annotation.query.replace('$timeFilter', timeFilter);\n    query = this.templateSrv.replace(query, undefined, 'regex');\n\n    return this._seriesQuery(query, options)\n      .toPromise()\n      .then((data: any) => {\n        if (!data || !data.results || !data.results[0]) {\n          throw { message: 'No results in response from InfluxDB' };\n        }\n        return new InfluxSeries({\n          series: data.results[0].series,\n          annotation: options.annotation,\n        }).getAnnotations();\n      });\n  }\n\n  targetContainsTemplate(target: any) {\n    // for flux-mode we just take target.query,\n    // for influxql-mode we use InfluxQueryModel to create the text-representation\n    const queryText = this.isFlux ? target.query : buildRawQuery(target);\n\n    return this.templateSrv.variableExists(queryText);\n  }\n\n  interpolateVariablesInQueries(queries: InfluxQuery[], scopedVars: ScopedVars): InfluxQuery[] {\n    if (!queries || queries.length === 0) {\n      return [];\n    }\n\n    let expandedQueries = queries;\n    if (queries && queries.length > 0) {\n      expandedQueries = queries.map((query) => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          measurement: this.templateSrv.replace(query.measurement ?? '', scopedVars, 'regex'),\n          policy: this.templateSrv.replace(query.policy ?? '', scopedVars, 'regex'),\n        };\n\n        if (query.rawQuery) {\n          expandedQuery.query = this.templateSrv.replace(query.query ?? '', scopedVars, 'regex');\n        }\n\n        if (query.tags) {\n          expandedQuery.tags = query.tags.map((tag) => {\n            return {\n              ...tag,\n              value: this.templateSrv.replace(tag.value, undefined, 'regex'),\n            };\n          });\n        }\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  async metricFindQuery(query: string, options?: any): Promise<MetricFindValue[]> {\n    if (this.isFlux) {\n      const target: InfluxQuery = {\n        refId: 'metricFindQuery',\n        query,\n      };\n      return super\n        .query({\n          ...options, // includes 'range'\n          targets: [target],\n        } as DataQueryRequest)\n        .toPromise()\n        .then((rsp) => {\n          if (rsp.data?.length) {\n            return frameToMetricFindValue(rsp.data[0]);\n          }\n          return [];\n        });\n    }\n\n    const interpolated = this.templateSrv.replace(query, undefined, 'regex');\n\n    return this._seriesQuery(interpolated, options)\n      .toPromise()\n      .then((resp) => {\n        return this.responseParser.parse(query, resp);\n      });\n  }\n\n  getTagKeys(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_KEYS');\n    return this.metricFindQuery(query, options);\n  }\n\n  getTagValues(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_VALUES', options.key);\n    return this.metricFindQuery(query, options);\n  }\n\n  _seriesQuery(query: string, options?: any) {\n    if (!query) {\n      return of({ results: [] });\n    }\n\n    if (options && options.range) {\n      const timeFilter = this.getTimeFilter({ rangeRaw: options.range, timezone: options.timezone });\n      query = query.replace('$timeFilter', timeFilter);\n    }\n\n    return this._influxRequest(this.httpMode, '/query', { q: query, epoch: 'ms' }, options);\n  }\n\n  serializeParams(params: any) {\n    if (!params) {\n      return '';\n    }\n\n    return reduce(\n      params,\n      (memo, value, key) => {\n        if (value === null || value === undefined) {\n          return memo;\n        }\n        memo.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n        return memo;\n      },\n      [] as string[]\n    ).join('&');\n  }\n\n  testDatasource() {\n    if (this.isFlux) {\n      // TODO: eventually use the real /health endpoint\n      const request: DataQueryRequest<InfluxQuery> = {\n        targets: [{ refId: 'test', query: 'buckets()' }],\n        requestId: `${this.id}-health-${uuidv4()}`,\n        dashboardId: 0,\n        panelId: 0,\n        interval: '1m',\n        intervalMs: 60000,\n        maxDataPoints: 423,\n        range: {\n          from: dateTime(1000),\n          to: dateTime(2000),\n        },\n      } as DataQueryRequest<InfluxQuery>;\n\n      return super\n        .query(request)\n        .toPromise()\n        .then((res: DataQueryResponse) => {\n          if (!res || !res.data || res.state !== LoadingState.Done) {\n            console.error('InfluxDB Error', res);\n            return { status: 'error', message: 'Error reading InfluxDB' };\n          }\n          const first = res.data[0];\n          if (first && first.length) {\n            return { status: 'success', message: `${first.length} buckets found` };\n          }\n          console.error('InfluxDB Error', res);\n          return { status: 'error', message: 'Error reading buckets' };\n        })\n        .catch((err: any) => {\n          console.error('InfluxDB Error', err);\n          return { status: 'error', message: err.message };\n        });\n    }\n\n    const queryBuilder = new InfluxQueryBuilder({ measurement: '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('RETENTION POLICIES');\n\n    return this._seriesQuery(query)\n      .toPromise()\n      .then((res: any) => {\n        const error = get(res, 'results[0].error');\n        if (error) {\n          return { status: 'error', message: error };\n        }\n        return { status: 'success', message: 'Data source is working' };\n      })\n      .catch((err: any) => {\n        return { status: 'error', message: err.message };\n      });\n  }\n\n  _influxRequest(method: string, url: string, data: any, options?: any) {\n    const currentUrl = this.urls.shift()!;\n    this.urls.push(currentUrl);\n\n    const params: any = {};\n\n    if (this.username) {\n      params.u = this.username;\n      params.p = this.password;\n    }\n\n    if (options && options.database) {\n      params.db = options.database;\n    } else if (this.database) {\n      params.db = this.database;\n    }\n\n    const { q } = data;\n\n    if (method === 'POST' && has(data, 'q')) {\n      // verb is POST and 'q' param is defined\n      extend(params, omit(data, ['q']));\n      data = this.serializeParams(pick(data, ['q']));\n    } else if (method === 'GET' || method === 'POST') {\n      // verb is GET, or POST without 'q' param\n      extend(params, data);\n      data = null;\n    }\n\n    const req: any = {\n      method: method,\n      url: currentUrl + url,\n      params: params,\n      data: data,\n      precision: 'ms',\n      inspect: { type: 'influxdb' },\n      paramSerializer: this.serializeParams,\n    };\n\n    req.headers = req.headers || {};\n    if (this.basicAuth || this.withCredentials) {\n      req.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      req.headers.Authorization = this.basicAuth;\n    }\n\n    if (method === 'POST') {\n      req.headers['Content-type'] = 'application/x-www-form-urlencoded';\n    }\n\n    return getBackendSrv()\n      .fetch(req)\n      .pipe(\n        map((result: any) => {\n          const { data } = result;\n          if (data) {\n            data.executedQueryString = q;\n            if (data.results) {\n              const errors = result.data.results.filter((elem: any) => elem.error);\n\n              if (errors.length > 0) {\n                throw {\n                  message: 'InfluxDB Error: ' + errors[0].error,\n                  data,\n                };\n              }\n            }\n          }\n          return data;\n        }),\n        catchError((err) => {\n          if (err.cancelled) {\n            return of(err);\n          }\n\n          return throwError(this.handleErrors(err));\n        })\n      );\n  }\n\n  handleErrors(err: any) {\n    const error: DataQueryError = {\n      message:\n        (err && err.status) ||\n        (err && err.message) ||\n        'Unknown error during query transaction. Please check JS console logs.',\n    };\n\n    if ((Number.isInteger(err.status) && err.status !== 0) || err.status >= 300) {\n      if (err.data && err.data.error) {\n        error.message = 'InfluxDB Error: ' + err.data.error;\n        error.data = err.data;\n        // @ts-ignore\n        error.config = err.config;\n      } else {\n        error.message = 'Network Error: ' + err.statusText + '(' + err.status + ')';\n        error.data = err.data;\n        // @ts-ignore\n        error.config = err.config;\n      }\n    }\n\n    return error;\n  }\n\n  getTimeFilter(options: any) {\n    const from = this.getInfluxTime(options.rangeRaw.from, false, options.timezone);\n    const until = this.getInfluxTime(options.rangeRaw.to, true, options.timezone);\n\n    return 'time >= ' + from + ' and time <= ' + until;\n  }\n\n  getInfluxTime(date: any, roundUp: any, timezone: any) {\n    if (isString(date)) {\n      if (date === 'now') {\n        return 'now()';\n      }\n\n      const parts = /^now-(\\d+)([dhms])$/.exec(date);\n      if (parts) {\n        const amount = parseInt(parts[1], 10);\n        const unit = parts[2];\n        return 'now() - ' + amount + unit;\n      }\n      date = dateMath.parse(date, roundUp, timezone);\n    }\n\n    return date.valueOf() + 'ms';\n  }\n}\n","import { useState, useEffect } from 'react';\nimport { usePrevious } from 'react-use';\n\nexport function useShadowedState<T>(outsideVal: T): [T, (newVal: T) => void] {\n  const [currentVal, setCurrentVal] = useState(outsideVal);\n  const prevOutsideVal = usePrevious(outsideVal);\n\n  useEffect(() => {\n    const isOutsideValChanged = prevOutsideVal !== outsideVal;\n    // if the value changes from the outside, we accept it into the state\n    // (we only set it if it is different from the current value)\n    if (isOutsideValChanged && currentVal !== outsideVal) {\n      setCurrentVal(outsideVal);\n    }\n  }, [outsideVal, currentVal, prevOutsideVal]);\n\n  return [currentVal, setCurrentVal];\n}\n","import { useRef } from 'react';\nimport { uniqueId } from 'lodash';\n\nexport function useUniqueId(): string {\n  // we need to lazy-init this ref.\n  // otherwise we would call `uniqueId`\n  // on every render. unfortunately\n  // useRef does not have lazy-init builtin,\n  // like useState does. we do it manually.\n  const idRefLazy = useRef<string | null>(null);\n\n  if (idRefLazy.current == null) {\n    idRefLazy.current = uniqueId();\n  }\n\n  return idRefLazy.current;\n}\n","import { SelectableValue } from '@grafana/data';\nimport { ResultFormat } from '../types';\n\nexport const RESULT_FORMATS: Array<SelectableValue<ResultFormat>> = [\n  { label: 'Time series', value: 'time_series' },\n  { label: 'Table', value: 'table' },\n  { label: 'Logs', value: 'logs' },\n];\n\nexport const DEFAULT_RESULT_FORMAT: ResultFormat = 'time_series';\n","import React from 'react';\nimport { TextArea, InlineFormLabel, Input, Select, HorizontalGroup } from '@grafana/ui';\nimport { InfluxQuery } from '../types';\nimport { useShadowedState } from './useShadowedState';\nimport { useUniqueId } from './useUniqueId';\nimport { RESULT_FORMATS, DEFAULT_RESULT_FORMAT } from './constants';\n\ntype Props = {\n  query: InfluxQuery;\n  onChange: (query: InfluxQuery) => void;\n  onRunQuery: () => void;\n};\n\n// we handle 3 fields: \"query\", \"alias\", \"resultFormat\"\n// \"resultFormat\" changes are applied immediately\n// \"query\" and \"alias\" changes only happen on onblur\nexport const RawInfluxQLEditor = ({ query, onChange, onRunQuery }: Props): JSX.Element => {\n  const [currentQuery, setCurrentQuery] = useShadowedState(query.query);\n  const [currentAlias, setCurrentAlias] = useShadowedState(query.alias);\n  const aliasElementId = useUniqueId();\n  const selectElementId = useUniqueId();\n\n  const applyDelayedChangesAndRunQuery = () => {\n    onChange({\n      ...query,\n      query: currentQuery,\n      alias: currentAlias,\n    });\n    onRunQuery();\n  };\n\n  return (\n    <div>\n      <TextArea\n        aria-label=\"query\"\n        rows={3}\n        spellCheck={false}\n        placeholder=\"InfluxDB Query\"\n        onBlur={applyDelayedChangesAndRunQuery}\n        onChange={(e) => {\n          setCurrentQuery(e.currentTarget.value);\n        }}\n        value={currentQuery ?? ''}\n      />\n      <HorizontalGroup>\n        <InlineFormLabel htmlFor={selectElementId}>Format as</InlineFormLabel>\n        <Select\n          menuShouldPortal\n          inputId={selectElementId}\n          onChange={(v) => {\n            onChange({ ...query, resultFormat: v.value });\n            onRunQuery();\n          }}\n          value={query.resultFormat ?? DEFAULT_RESULT_FORMAT}\n          options={RESULT_FORMATS}\n        />\n        <InlineFormLabel htmlFor={aliasElementId}>Alias by</InlineFormLabel>\n        <Input\n          id={aliasElementId}\n          type=\"text\"\n          spellCheck={false}\n          placeholder=\"Naming pattern\"\n          onBlur={applyDelayedChangesAndRunQuery}\n          onChange={(e) => {\n            setCurrentAlias(e.currentTarget.value);\n          }}\n          value={currentAlias ?? ''}\n        />\n      </HorizontalGroup>\n    </div>\n  );\n};\n","import React, { useState, useEffect } from 'react';\nimport debouncePromise from 'debounce-promise';\nimport { cx, css } from '@emotion/css';\nimport { SelectableValue } from '@grafana/data';\nimport { useAsyncFn } from 'react-use';\nimport { InlineLabel, Select, AsyncSelect, Input } from '@grafana/ui';\nimport { useShadowedState } from '../useShadowedState';\n\n// this file is a simpler version of `grafana-ui / SegmentAsync.tsx`\n// with some changes:\n// 1. click-outside does not select the value. i think it's better to be explicit here.\n// 2. we set a min-width on the select-element to handle cases where the `value`\n//    is very short, like \"x\", and then you click on it and the select opens,\n//    and it tries to be as short as \"x\" and it does not work well.\n\n// NOTE: maybe these changes could be migrated into the SegmentAsync later\n\ntype SelVal = SelectableValue<string>;\n\n// when allowCustomValue is true, there is no way to enforce the selectableValue\n// enum-type, so i just go with `string`\n\ntype LoadOptions = (filter: string) => Promise<SelVal[]>;\n\ntype Props = {\n  value: string;\n  buttonClassName?: string;\n  loadOptions?: LoadOptions;\n  // if filterByLoadOptions is false,\n  // loadOptions is only executed once,\n  // when the select-box opens,\n  // and as you write, the list gets filtered\n  // by the select-box.\n  // if filterByLoadOptions is true,\n  // as you write the loadOptions is executed again and again,\n  // and it is relied on to filter the results.\n  filterByLoadOptions?: boolean;\n  onChange: (v: SelVal) => void;\n  allowCustomValue?: boolean;\n};\n\nconst selectClass = css({\n  minWidth: '160px',\n});\n\ntype SelProps = {\n  loadOptions: LoadOptions;\n  filterByLoadOptions?: boolean;\n  onClose: () => void;\n  onChange: (v: SelVal) => void;\n  allowCustomValue?: boolean;\n};\n\ntype SelReloadProps = {\n  loadOptions: (filter: string) => Promise<SelVal[]>;\n  onClose: () => void;\n  onChange: (v: SelVal) => void;\n  allowCustomValue?: boolean;\n};\n\n// when a custom value is written into a select-box,\n// by default the new value is prefixed with \"Create:\",\n// and that sounds confusing because here we do not create\n// anything. we change this to just be the entered string.\nconst formatCreateLabel = (v: string) => v;\n\nconst SelReload = ({ loadOptions, allowCustomValue, onChange, onClose }: SelReloadProps): JSX.Element => {\n  // here we rely on the fact that writing text into the <AsyncSelect/>\n  // does not cause a re-render of the current react component.\n  // this way there is only a single render-call,\n  // so there is only a single `debouncedLoadOptions`.\n  // if we want ot make this \"re-render safe,\n  // we will have to put the debounced call into an useRef,\n  // and probably have an useEffect\n  const debouncedLoadOptions = debouncePromise(loadOptions, 1000, { leading: true });\n  return (\n    <div className={selectClass}>\n      <AsyncSelect\n        menuShouldPortal\n        formatCreateLabel={formatCreateLabel}\n        defaultOptions\n        autoFocus\n        isOpen\n        onCloseMenu={onClose}\n        allowCustomValue={allowCustomValue}\n        loadOptions={debouncedLoadOptions}\n        onChange={onChange}\n      />\n    </div>\n  );\n};\n\ntype SelSingleLoadProps = {\n  loadOptions: (filter: string) => Promise<SelVal[]>;\n  onClose: () => void;\n  onChange: (v: SelVal) => void;\n  allowCustomValue?: boolean;\n};\n\nconst SelSingleLoad = ({ loadOptions, allowCustomValue, onChange, onClose }: SelSingleLoadProps): JSX.Element => {\n  const [loadState, doLoad] = useAsyncFn(loadOptions, [loadOptions]);\n\n  useEffect(() => {\n    doLoad();\n  }, [doLoad, loadOptions]);\n\n  return (\n    <div className={selectClass}>\n      <Select\n        menuShouldPortal\n        isLoading={loadState.loading}\n        formatCreateLabel={formatCreateLabel}\n        autoFocus\n        isOpen\n        onCloseMenu={onClose}\n        allowCustomValue={allowCustomValue}\n        options={loadState.value ?? []}\n        onChange={onChange}\n      />\n    </div>\n  );\n};\n\nconst Sel = ({ loadOptions, filterByLoadOptions, allowCustomValue, onChange, onClose }: SelProps): JSX.Element => {\n  // unfortunately <Segment/> and <SegmentAsync/> have somewhat different behavior,\n  // so the simplest approach was to just create two separate wrapper-components\n  return filterByLoadOptions ? (\n    <SelReload loadOptions={loadOptions} allowCustomValue={allowCustomValue} onChange={onChange} onClose={onClose} />\n  ) : (\n    <SelSingleLoad\n      loadOptions={loadOptions}\n      allowCustomValue={allowCustomValue}\n      onChange={onChange}\n      onClose={onClose}\n    />\n  );\n};\n\ntype InpProps = {\n  initialValue: string;\n  onChange: (newVal: string) => void;\n  onClose: () => void;\n};\n\nconst Inp = ({ initialValue, onChange, onClose }: InpProps): JSX.Element => {\n  const [currentValue, setCurrentValue] = useShadowedState(initialValue);\n\n  return (\n    <Input\n      autoFocus\n      type=\"text\"\n      spellCheck={false}\n      onBlur={onClose}\n      onKeyDown={(e) => {\n        if (e.key === 'Enter') {\n          onChange(currentValue);\n        }\n      }}\n      onChange={(e) => {\n        setCurrentValue(e.currentTarget.value);\n      }}\n      value={currentValue}\n    />\n  );\n};\n\nconst defaultButtonClass = css({\n  width: 'auto',\n  cursor: 'pointer',\n});\n\nexport const Seg = ({\n  value,\n  buttonClassName,\n  loadOptions,\n  filterByLoadOptions,\n  allowCustomValue,\n  onChange,\n}: Props): JSX.Element => {\n  const [isOpen, setOpen] = useState(false);\n  if (!isOpen) {\n    const className = cx(defaultButtonClass, buttonClassName);\n    return (\n      <InlineLabel\n        as=\"button\"\n        className={className}\n        onClick={() => {\n          setOpen(true);\n        }}\n      >\n        {value}\n      </InlineLabel>\n    );\n  } else {\n    if (loadOptions !== undefined) {\n      return (\n        <Sel\n          loadOptions={loadOptions}\n          filterByLoadOptions={filterByLoadOptions ?? false}\n          allowCustomValue={allowCustomValue}\n          onChange={(v) => {\n            setOpen(false);\n            onChange(v);\n          }}\n          onClose={() => {\n            setOpen(false);\n          }}\n        />\n      );\n    } else {\n      return (\n        <Inp\n          initialValue={value}\n          onClose={() => {\n            setOpen(false);\n          }}\n          onChange={(v) => {\n            setOpen(false);\n            onChange({ value: v, label: v });\n          }}\n        />\n      );\n    }\n  }\n};\n","import { SelectableValue } from '@grafana/data';\n\nexport function toSelectableValue<T extends string>(t: T): SelectableValue<T> {\n  return { label: t, value: t };\n}\n","import React from 'react';\nimport { Seg } from './Seg';\nimport { toSelectableValue } from './toSelectableValue';\n\nconst DEFAULT_POLICY = 'default';\n\n// we use the value \"default\" as a magic-value, it means\n// we use the default retention-policy.\n// unfortunately, IF the user has a retention-policy named \"default\",\n// and it is not the default-retention-policy in influxdb,\n// bad things will happen.\n// https://github.com/grafana/grafana/issues/4347 :-(\n// FIXME: we could maybe at least detect here that problem-is-happening,\n// and show an error message or something.\n// unfortunately, currently the ResponseParser does not return the\n// is-default info for the retention-policies, so that should change first.\n\ntype Props = {\n  onChange: (policy: string | undefined, measurement: string | undefined) => void;\n  policy: string | undefined;\n  measurement: string | undefined;\n  getPolicyOptions: () => Promise<string[]>;\n  getMeasurementOptions: (filter: string) => Promise<string[]>;\n};\n\nexport const FromSection = ({\n  policy,\n  measurement,\n  onChange,\n  getPolicyOptions,\n  getMeasurementOptions,\n}: Props): JSX.Element => {\n  const handlePolicyLoadOptions = async () => {\n    const allPolicies = await getPolicyOptions();\n    // if `default` does not exist in the list of policies, we add it\n    const allPoliciesWithDefault = allPolicies.some((p) => p === 'default')\n      ? allPolicies\n      : [DEFAULT_POLICY, ...allPolicies];\n\n    return allPoliciesWithDefault.map(toSelectableValue);\n  };\n\n  const handleMeasurementLoadOptions = async (filter: string) => {\n    const allMeasurements = await getMeasurementOptions(filter);\n    return allMeasurements.map(toSelectableValue);\n  };\n\n  return (\n    <>\n      <Seg\n        allowCustomValue\n        value={policy ?? 'using default policy'}\n        loadOptions={handlePolicyLoadOptions}\n        onChange={(v) => {\n          onChange(v.value, measurement);\n        }}\n      />\n      <Seg\n        allowCustomValue\n        value={measurement ?? 'select measurement'}\n        loadOptions={handleMeasurementLoadOptions}\n        filterByLoadOptions\n        onChange={(v) => {\n          onChange(policy, v.value);\n        }}\n      />\n    </>\n  );\n};\n","import { InfluxQueryTag } from '../../types';\n\nfunction isRegex(text: string): boolean {\n  return /^\\/.*\\/$/.test(text);\n}\n\n// FIXME: sync these to the query-string-generation-code\n// probably it's in influx_query_model.ts\nexport function getOperator(tag: InfluxQueryTag): string {\n  return tag.operator ?? (isRegex(tag.value) ? '=~' : '=');\n}\n\n// FIXME: sync these to the query-string-generation-code\n// probably it's in influx_query_model.ts\nexport function getCondition(tag: InfluxQueryTag, isFirst: boolean): string | undefined {\n  return isFirst ? undefined : tag.condition ?? 'AND';\n}\n\nexport function adjustOperatorIfNeeded(currentOperator: string, newTagValue: string): string {\n  const isCurrentOperatorRegex = currentOperator === '=~' || currentOperator === '!~';\n  const isNewTagValueRegex = isRegex(newTagValue);\n\n  if (isNewTagValueRegex) {\n    return isCurrentOperatorRegex ? currentOperator : '=~';\n  } else {\n    return isCurrentOperatorRegex ? '=' : currentOperator;\n  }\n}\n","export function unwrap<T>(value: T | null | undefined): T {\n  if (value == null) {\n    throw new Error('value must not be nullish');\n  }\n  return value;\n}\n","import React from 'react';\nimport { SelectableValue } from '@grafana/data';\nimport { Seg } from './Seg';\nimport { unwrap } from './unwrap';\n\ntype Props = {\n  loadOptions: () => Promise<SelectableValue[]>;\n  allowCustomValue?: boolean;\n  onAdd: (v: string) => void;\n};\n\nexport const AddButton = ({ loadOptions, allowCustomValue, onAdd }: Props): JSX.Element => {\n  return (\n    <Seg\n      value=\"+\"\n      loadOptions={loadOptions}\n      allowCustomValue={allowCustomValue}\n      onChange={(v) => {\n        onAdd(unwrap(v.value));\n      }}\n    />\n  );\n};\n","import React from 'react';\nimport { SelectableValue } from '@grafana/data';\nimport { Seg } from './Seg';\nimport { InfluxQueryTag } from '../../types';\nimport { toSelectableValue } from './toSelectableValue';\nimport { adjustOperatorIfNeeded, getCondition, getOperator } from './tagUtils';\nimport { AddButton } from './AddButton';\n\ntype KnownOperator = '=' | '!=' | '<>' | '<' | '>' | '=~' | '!~';\nconst knownOperators: KnownOperator[] = ['=', '!=', '<>', '<', '>', '=~', '!~'];\n\ntype KnownCondition = 'AND' | 'OR';\nconst knownConditions: KnownCondition[] = ['AND', 'OR'];\n\nconst operatorOptions: Array<SelectableValue<KnownOperator>> = knownOperators.map(toSelectableValue);\nconst condititonOptions: Array<SelectableValue<KnownCondition>> = knownConditions.map(toSelectableValue);\n\ntype Props = {\n  tags: InfluxQueryTag[];\n  onChange: (tags: InfluxQueryTag[]) => void;\n  getTagKeyOptions: () => Promise<string[]>;\n  getTagValueOptions: (key: string) => Promise<string[]>;\n};\n\ntype TagProps = {\n  tag: InfluxQueryTag;\n  isFirst: boolean;\n  onRemove: () => void;\n  onChange: (tag: InfluxQueryTag) => void;\n  getTagKeyOptions: () => Promise<string[]>;\n  getTagValueOptions: (key: string) => Promise<string[]>;\n};\n\nconst loadConditionOptions = () => Promise.resolve(condititonOptions);\n\nconst loadOperatorOptions = () => Promise.resolve(operatorOptions);\n\nconst Tag = ({ tag, isFirst, onRemove, onChange, getTagKeyOptions, getTagValueOptions }: TagProps): JSX.Element => {\n  const operator = getOperator(tag);\n  const condition = getCondition(tag, isFirst);\n\n  const getTagKeySegmentOptions = () => {\n    return getTagKeyOptions().then((tags) => [\n      { label: '-- remove filter --', value: undefined },\n      ...tags.map(toSelectableValue),\n    ]);\n  };\n\n  const getTagValueSegmentOptions = () => {\n    return getTagValueOptions(tag.key).then((tags) => tags.map(toSelectableValue));\n  };\n\n  return (\n    <div className=\"gf-form\">\n      {condition != null && (\n        <Seg\n          value={condition}\n          loadOptions={loadConditionOptions}\n          onChange={(v) => {\n            onChange({ ...tag, condition: v.value });\n          }}\n        />\n      )}\n      <Seg\n        allowCustomValue\n        value={tag.key}\n        loadOptions={getTagKeySegmentOptions}\n        onChange={(v) => {\n          const { value } = v;\n          if (value === undefined) {\n            onRemove();\n          } else {\n            onChange({ ...tag, key: value ?? '' });\n          }\n        }}\n      />\n      <Seg\n        value={operator}\n        loadOptions={loadOperatorOptions}\n        onChange={(op) => {\n          onChange({ ...tag, operator: op.value });\n        }}\n      />\n      <Seg\n        allowCustomValue\n        value={tag.value}\n        loadOptions={getTagValueSegmentOptions}\n        onChange={(v) => {\n          const value = v.value ?? '';\n          onChange({ ...tag, value, operator: adjustOperatorIfNeeded(operator, value) });\n        }}\n      />\n    </div>\n  );\n};\n\nexport const TagsSection = ({ tags, onChange, getTagKeyOptions, getTagValueOptions }: Props): JSX.Element => {\n  const onTagChange = (newTag: InfluxQueryTag, index: number) => {\n    const newTags = tags.map((tag, i) => {\n      return index === i ? newTag : tag;\n    });\n    onChange(newTags);\n  };\n\n  const onTagRemove = (index: number) => {\n    const newTags = tags.filter((t, i) => i !== index);\n    onChange(newTags);\n  };\n\n  const getTagKeySegmentOptions = () => {\n    return getTagKeyOptions().then((tags) => tags.map(toSelectableValue));\n  };\n\n  const addNewTag = (tagKey: string, isFirst: boolean) => {\n    const minimalTag: InfluxQueryTag = {\n      key: tagKey,\n      value: 'select tag value',\n    };\n\n    const newTag: InfluxQueryTag = {\n      key: minimalTag.key,\n      value: minimalTag.value,\n      operator: getOperator(minimalTag),\n      condition: getCondition(minimalTag, isFirst),\n    };\n\n    onChange([...tags, newTag]);\n  };\n\n  return (\n    <>\n      {tags.map((t, i) => (\n        <Tag\n          tag={t}\n          isFirst={i === 0}\n          key={i}\n          onChange={(newT) => {\n            onTagChange(newT, i);\n          }}\n          onRemove={() => {\n            onTagRemove(i);\n          }}\n          getTagKeyOptions={getTagKeyOptions}\n          getTagValueOptions={getTagValueOptions}\n        />\n      ))}\n      <AddButton\n        allowCustomValue\n        loadOptions={getTagKeySegmentOptions}\n        onAdd={(v) => {\n          addNewTag(v, tags.length === 0);\n        }}\n      />\n    </>\n  );\n};\n","import React, { useMemo } from 'react';\nimport { cx, css } from '@emotion/css';\nimport { MenuItem, WithContextMenu, MenuGroup, useTheme2 } from '@grafana/ui';\nimport { SelectableValue, GrafanaTheme2 } from '@grafana/data';\nimport { Seg } from './Seg';\nimport { unwrap } from './unwrap';\nimport { toSelectableValue } from './toSelectableValue';\nimport { AddButton } from './AddButton';\n\nexport type PartParams = Array<{\n  value: string;\n  options: (() => Promise<string[]>) | null;\n}>;\n\ntype Props = {\n  parts: Array<{\n    name: string;\n    params: PartParams;\n  }>;\n  getNewPartOptions: () => Promise<SelectableValue[]>;\n  onChange: (partIndex: number, paramValues: string[]) => void;\n  onRemovePart: (index: number) => void;\n  onAddNewPart: (type: string) => void;\n};\n\nconst renderRemovableNameMenuItems = (onClick: () => void) => {\n  return (\n    <MenuGroup label=\"\" ariaLabel=\"\">\n      <MenuItem label=\"remove\" ariaLabel=\"remove\" onClick={onClick} />\n    </MenuGroup>\n  );\n};\n\nconst noRightMarginPaddingClass = css({\n  paddingRight: '0',\n  marginRight: '0',\n});\n\nconst RemovableName = ({ name, onRemove }: { name: string; onRemove: () => void }) => {\n  return (\n    <WithContextMenu renderMenuItems={() => renderRemovableNameMenuItems(onRemove)}>\n      {({ openMenu }) => (\n        <button className={cx('gf-form-label', noRightMarginPaddingClass)} onClick={openMenu}>\n          {name}\n        </button>\n      )}\n    </WithContextMenu>\n  );\n};\n\ntype PartProps = {\n  name: string;\n  params: PartParams;\n  onRemove: () => void;\n  onChange: (paramValues: string[]) => void;\n};\n\nconst noHorizMarginPaddingClass = css({\n  paddingLeft: '0',\n  paddingRight: '0',\n  marginLeft: '0',\n  marginRight: '0',\n});\n\nconst getPartClass = (theme: GrafanaTheme2) => {\n  return cx(\n    'gf-form-label',\n    css({\n      paddingLeft: '0',\n      // gf-form-label class makes certain css attributes incorrect\n      // for the selectbox-dropdown, so we have to \"reset\" them back\n      lineHeight: theme.typography.body.lineHeight,\n      fontSize: theme.typography.body.fontSize,\n    })\n  );\n};\n\nconst Part = ({ name, params, onChange, onRemove }: PartProps): JSX.Element => {\n  const theme = useTheme2();\n  const partClass = useMemo(() => getPartClass(theme), [theme]);\n\n  const onParamChange = (par: string, i: number) => {\n    const newParams = params.map((p) => p.value);\n    newParams[i] = par;\n    onChange(newParams);\n  };\n  return (\n    <div className={partClass}>\n      <RemovableName name={name} onRemove={onRemove} />(\n      {params.map((p, i) => {\n        const { value, options } = p;\n        const isLast = i === params.length - 1;\n        const loadOptions =\n          options !== null ? () => options().then((items) => items.map(toSelectableValue)) : undefined;\n        return (\n          <React.Fragment key={i}>\n            <Seg\n              allowCustomValue\n              value={value}\n              buttonClassName={noHorizMarginPaddingClass}\n              loadOptions={loadOptions}\n              onChange={(v) => {\n                onParamChange(unwrap(v.value), i);\n              }}\n            />\n            {!isLast && ','}\n          </React.Fragment>\n        );\n      })}\n      )\n    </div>\n  );\n};\n\nexport const PartListSection = ({\n  parts,\n  getNewPartOptions,\n  onAddNewPart,\n  onRemovePart,\n  onChange,\n}: Props): JSX.Element => {\n  return (\n    <>\n      {parts.map((part, index) => (\n        <Part\n          key={index}\n          name={part.name}\n          params={part.params}\n          onRemove={() => {\n            onRemovePart(index);\n          }}\n          onChange={(pars) => {\n            onChange(index, pars);\n          }}\n        />\n      ))}\n      <AddButton loadOptions={getNewPartOptions} onAdd={onAddNewPart} />\n    </>\n  );\n};\n","import { css } from '@emotion/css';\n\nexport const paddingRightClass = css({\n  paddingRight: '4px',\n});\n","import React from 'react';\nimport { cx } from '@emotion/css';\nimport { SelectableValue } from '@grafana/data';\nimport { unwrap } from './unwrap';\nimport { Select } from '@grafana/ui';\nimport { paddingRightClass } from './styles';\n\ntype Mode = 'ASC' | 'DESC';\n\nconst OPTIONS: Array<SelectableValue<Mode>> = [\n  { label: 'ascending', value: 'ASC' },\n  { label: 'descending', value: 'DESC' },\n];\n\nconst className = cx('width-9', paddingRightClass);\n\ntype Props = {\n  value: Mode;\n  onChange: (value: Mode) => void;\n};\n\nexport const OrderByTimeSection = ({ value, onChange }: Props): JSX.Element => {\n  return (\n    <>\n      <Select<Mode>\n        className={className}\n        onChange={(v) => {\n          onChange(unwrap(v.value));\n        }}\n        value={value}\n        options={OPTIONS}\n      />\n    </>\n  );\n};\n","import React from 'react';\nimport { cx } from '@emotion/css';\nimport { Input } from '@grafana/ui';\nimport { useShadowedState } from '../useShadowedState';\nimport { paddingRightClass } from './styles';\n\ntype Props = {\n  value: string | undefined;\n  onChange: (value: string | undefined) => void;\n  isWide?: boolean;\n  placeholder?: string;\n};\n\nexport const InputSection = ({ value, onChange, isWide, placeholder }: Props): JSX.Element => {\n  const [currentValue, setCurrentValue] = useShadowedState(value);\n\n  const onBlur = () => {\n    // we send empty-string as undefined\n    const newValue = currentValue === '' ? undefined : currentValue;\n    onChange(newValue);\n  };\n\n  return (\n    <>\n      <Input\n        placeholder={placeholder}\n        className={cx(isWide ?? false ? 'width-14' : 'width-8', paddingRightClass)}\n        type=\"text\"\n        spellCheck={false}\n        onBlur={onBlur}\n        onChange={(e) => {\n          setCurrentValue(e.currentTarget.value);\n        }}\n        value={currentValue ?? ''}\n      />\n    </>\n  );\n};\n","import { InfluxQueryTag } from './types';\nimport InfluxDatasource from './datasource';\nimport { InfluxQueryBuilder } from './query_builder';\n\nconst runExploreQuery = (\n  type: string,\n  withKey: string | undefined,\n  withMeasurementFilter: string | undefined,\n  target: { measurement: string | undefined; tags: InfluxQueryTag[]; policy: string | undefined },\n  datasource: InfluxDatasource\n): Promise<Array<{ text: string }>> => {\n  const builder = new InfluxQueryBuilder(target, datasource.database);\n  const q = builder.buildExploreQuery(type, withKey, withMeasurementFilter);\n  return datasource.metricFindQuery(q);\n};\n\nexport async function getAllPolicies(datasource: InfluxDatasource): Promise<string[]> {\n  const target = { tags: [], measurement: undefined, policy: undefined };\n  const data = await runExploreQuery('RETENTION POLICIES', undefined, undefined, target, datasource);\n  return data.map((item) => item.text);\n}\n\nexport async function getAllMeasurementsForTags(\n  measurementFilter: string | undefined,\n  tags: InfluxQueryTag[],\n  datasource: InfluxDatasource\n): Promise<string[]> {\n  const target = { tags, measurement: undefined, policy: undefined };\n  const data = await runExploreQuery('MEASUREMENTS', undefined, measurementFilter, target, datasource);\n  return data.map((item) => item.text);\n}\n\nexport async function getTagKeysForMeasurementAndTags(\n  measurement: string | undefined,\n  policy: string | undefined,\n  tags: InfluxQueryTag[],\n  datasource: InfluxDatasource\n): Promise<string[]> {\n  const target = { tags, measurement, policy };\n  const data = await runExploreQuery('TAG_KEYS', undefined, undefined, target, datasource);\n  return data.map((item) => item.text);\n}\n\nexport async function getTagValues(\n  tagKey: string,\n  measurement: string | undefined,\n  policy: string | undefined,\n  tags: InfluxQueryTag[],\n  datasource: InfluxDatasource\n): Promise<string[]> {\n  const target = { tags, measurement, policy };\n  const data = await runExploreQuery('TAG_VALUES', tagKey, undefined, target, datasource);\n  return data.map((item) => item.text);\n}\n\nexport async function getFieldKeysForMeasurement(\n  measurement: string,\n  policy: string | undefined,\n  datasource: InfluxDatasource\n): Promise<string[]> {\n  const target = { tags: [], measurement, policy };\n  const data = await runExploreQuery('FIELDS', undefined, undefined, target, datasource);\n  return data.map((item) => item.text);\n}\n","import { Select } from '@grafana/ui';\nimport { cx } from '@emotion/css';\nimport { ResultFormat } from '../../types';\nimport React from 'react';\nimport { unwrap } from './unwrap';\nimport { RESULT_FORMATS } from '../constants';\nimport { paddingRightClass } from './styles';\n\ntype Props = {\n  format: ResultFormat;\n  onChange: (newFormat: ResultFormat) => void;\n};\n\nconst className = cx('width-8', paddingRightClass);\n\nexport const FormatAsSection = ({ format, onChange }: Props): JSX.Element => {\n  return (\n    <Select<ResultFormat>\n      className={className}\n      onChange={(v) => {\n        onChange(unwrap(v.value));\n      }}\n      value={format}\n      options={RESULT_FORMATS}\n    />\n  );\n};\n","import React from 'react';\nimport { cx, css } from '@emotion/css';\n\ntype Props = {\n  name: string;\n  isInitial?: boolean;\n};\n\nconst uppercaseClass = css({\n  textTransform: 'uppercase',\n});\n\nexport const SectionLabel = ({ name, isInitial }: Props) => (\n  <label className={cx('gf-form-label query-keyword', { 'width-7': isInitial ?? false }, uppercaseClass)}>{name}</label>\n);\n","import React from 'react';\n\nexport const SectionFill = () => (\n  <div className=\"gf-form gf-form--grow\">\n    <label className=\"gf-form-label gf-form-label--grow\"></label>\n  </div>\n);\n","import { InfluxQuery, InfluxQueryPart } from '../../types';\nimport { SelectableValue } from '@grafana/data';\nimport { PartParams } from './PartListSection';\nimport InfluxQueryModel from '../../influx_query_model';\nimport { unwrap } from './unwrap';\nimport queryPart from '../../query_part';\nimport { toSelectableValue } from './toSelectableValue';\nimport { QueryPartDef } from '../../../../../core/components/query_part/query_part';\n\ntype Categories = Record<string, QueryPartDef[]>;\n\nexport function getNewSelectPartOptions(): SelectableValue[] {\n  const categories: Categories = queryPart.getCategories();\n  const options: SelectableValue[] = [];\n\n  const keys = Object.keys(categories);\n\n  keys.forEach((key) => {\n    const children: SelectableValue[] = categories[key].map((x) => toSelectableValue(x.type));\n\n    options.push({\n      label: key,\n      options: children,\n    });\n  });\n\n  return options;\n}\n\nexport async function getNewGroupByPartOptions(\n  query: InfluxQuery,\n  getTagKeys: () => Promise<string[]>\n): Promise<Array<SelectableValue<string>>> {\n  const tagKeys = await getTagKeys();\n  const queryCopy = { ...query }; // the query-model mutates the query\n  const model = new InfluxQueryModel(queryCopy);\n  const options: Array<SelectableValue<string>> = [];\n  if (!model.hasFill()) {\n    options.push(toSelectableValue('fill(null)'));\n  }\n  if (!model.hasGroupByTime()) {\n    options.push(toSelectableValue('time($interval)'));\n  }\n  tagKeys.forEach((key) => {\n    options.push(toSelectableValue(`tag(${key})`));\n  });\n  return options;\n}\n\ntype Part = {\n  name: string;\n  params: PartParams;\n};\n\nfunction getPartParams(part: InfluxQueryPart, dynamicParamOptions: Map<string, () => Promise<string[]>>): PartParams {\n  // NOTE: the way the system is constructed,\n  // there always can only be one possible dynamic-lookup\n  // field. in case of select it is the field,\n  // in case of group-by it is the tag\n  const def = queryPart.create(part).def;\n\n  // we switch the numbers to strings, it will work that way too,\n  // and it makes the code simpler\n  const paramValues = (part.params ?? []).map((p) => p.toString());\n\n  if (paramValues.length !== def.params.length) {\n    throw new Error('Invalid query-segment');\n  }\n\n  return paramValues.map((val, index) => {\n    const defParam = def.params[index];\n    if (defParam.dynamicLookup) {\n      return {\n        value: val,\n        options: unwrap(dynamicParamOptions.get(`${def.type}_${index}`)),\n      };\n    }\n\n    if (defParam.options != null) {\n      return {\n        value: val,\n        options: () => Promise.resolve(defParam.options),\n      };\n    }\n\n    return {\n      value: val,\n      options: null,\n    };\n  });\n}\n\nexport function makePartList(\n  queryParts: InfluxQueryPart[],\n  dynamicParamOptions: Map<string, () => Promise<string[]>>\n): Part[] {\n  return queryParts.map((qp) => {\n    return {\n      name: qp.type,\n      params: getPartParams(qp, dynamicParamOptions),\n    };\n  });\n}\n","import React, { useMemo } from 'react';\nimport { InfluxQuery, InfluxQueryTag } from '../../types';\nimport { getTemplateSrv } from '@grafana/runtime';\nimport InfluxDatasource from '../../datasource';\nimport { FromSection } from './FromSection';\nimport { TagsSection } from './TagsSection';\nimport { PartListSection } from './PartListSection';\nimport { OrderByTimeSection } from './OrderByTimeSection';\nimport { InputSection } from './InputSection';\nimport {\n  getAllMeasurementsForTags,\n  getAllPolicies,\n  getFieldKeysForMeasurement,\n  getTagKeysForMeasurementAndTags,\n  getTagValues,\n} from '../../influxQLMetadataQuery';\nimport {\n  normalizeQuery,\n  addNewSelectPart,\n  removeSelectPart,\n  addNewGroupByPart,\n  removeGroupByPart,\n  changeSelectPart,\n  changeGroupByPart,\n} from '../../queryUtils';\nimport { FormatAsSection } from './FormatAsSection';\nimport { SectionLabel } from './SectionLabel';\nimport { SectionFill } from './SectionFill';\nimport { DEFAULT_RESULT_FORMAT } from '../constants';\nimport { getNewSelectPartOptions, getNewGroupByPartOptions, makePartList } from './partListUtils';\n\ntype Props = {\n  query: InfluxQuery;\n  onChange: (query: InfluxQuery) => void;\n  onRunQuery: () => void;\n  datasource: InfluxDatasource;\n};\n\nfunction getTemplateVariableOptions() {\n  return (\n    getTemplateSrv()\n      .getVariables()\n      // we make them regex-params, i'm not 100% sure why.\n      // probably because this way multi-value variables work ok too.\n      .map((v) => `/^$${v.name}$/`)\n  );\n}\n\n// helper function to make it easy to call this from the widget-render-code\nfunction withTemplateVariableOptions(optionsPromise: Promise<string[]>): Promise<string[]> {\n  return optionsPromise.then((options) => [...getTemplateVariableOptions(), ...options]);\n}\n\nconst SectionWrap = ({ initialName, children }: { initialName: string; children: React.ReactNode }) => (\n  <div className=\"gf-form-inline\">\n    <SectionLabel name={initialName} isInitial={true} />\n    {children}\n    <SectionFill />\n  </div>\n);\n\nexport const Editor = (props: Props): JSX.Element => {\n  const query = normalizeQuery(props.query);\n  const { datasource } = props;\n  const { measurement, policy } = query;\n\n  const selectLists = useMemo(() => {\n    const dynamicSelectPartOptions = new Map([\n      [\n        'field_0',\n        () => {\n          return measurement !== undefined\n            ? getFieldKeysForMeasurement(measurement, policy, datasource)\n            : Promise.resolve([]);\n        },\n      ],\n    ]);\n    return (query.select ?? []).map((sel) => makePartList(sel, dynamicSelectPartOptions));\n  }, [measurement, policy, query.select, datasource]);\n\n  // the following function is not complicated enough to memoize, but it's result\n  // is used in both memoized and un-memoized parts, so we have no choice\n  const getTagKeys = useMemo(() => {\n    return () => getTagKeysForMeasurementAndTags(measurement, policy, query.tags ?? [], datasource);\n  }, [measurement, policy, query.tags, datasource]);\n\n  const groupByList = useMemo(() => {\n    const dynamicGroupByPartOptions = new Map([['tag_0', getTagKeys]]);\n\n    return makePartList(query.groupBy ?? [], dynamicGroupByPartOptions);\n  }, [getTagKeys, query.groupBy]);\n\n  const onAppliedChange = (newQuery: InfluxQuery) => {\n    props.onChange(newQuery);\n    props.onRunQuery();\n  };\n  const handleFromSectionChange = (p: string | undefined, m: string | undefined) => {\n    onAppliedChange({\n      ...query,\n      policy: p,\n      measurement: m,\n    });\n  };\n\n  const handleTagsSectionChange = (tags: InfluxQueryTag[]) => {\n    // we set empty-arrays to undefined\n    onAppliedChange({\n      ...query,\n      tags: tags.length === 0 ? undefined : tags,\n    });\n  };\n\n  return (\n    <div>\n      <SectionWrap initialName=\"from\">\n        <FromSection\n          policy={policy}\n          measurement={measurement}\n          getPolicyOptions={() => getAllPolicies(datasource)}\n          getMeasurementOptions={(filter) =>\n            withTemplateVariableOptions(\n              getAllMeasurementsForTags(filter === '' ? undefined : filter, query.tags ?? [], datasource)\n            )\n          }\n          onChange={handleFromSectionChange}\n        />\n        <SectionLabel name=\"where\" />\n        <TagsSection\n          tags={query.tags ?? []}\n          onChange={handleTagsSectionChange}\n          getTagKeyOptions={getTagKeys}\n          getTagValueOptions={(key: string) =>\n            withTemplateVariableOptions(getTagValues(key, measurement, policy, query.tags ?? [], datasource))\n          }\n        />\n      </SectionWrap>\n      {selectLists.map((sel, index) => (\n        <SectionWrap key={index} initialName={index === 0 ? 'select' : ''}>\n          <PartListSection\n            parts={sel}\n            getNewPartOptions={() => Promise.resolve(getNewSelectPartOptions())}\n            onChange={(partIndex, newParams) => {\n              const newQuery = changeSelectPart(query, index, partIndex, newParams);\n              onAppliedChange(newQuery);\n            }}\n            onAddNewPart={(type) => {\n              onAppliedChange(addNewSelectPart(query, type, index));\n            }}\n            onRemovePart={(partIndex) => {\n              onAppliedChange(removeSelectPart(query, partIndex, index));\n            }}\n          />\n        </SectionWrap>\n      ))}\n      <SectionWrap initialName=\"group by\">\n        <PartListSection\n          parts={groupByList}\n          getNewPartOptions={() => getNewGroupByPartOptions(query, getTagKeys)}\n          onChange={(partIndex, newParams) => {\n            const newQuery = changeGroupByPart(query, partIndex, newParams);\n            onAppliedChange(newQuery);\n          }}\n          onAddNewPart={(type) => {\n            onAppliedChange(addNewGroupByPart(query, type));\n          }}\n          onRemovePart={(partIndex) => {\n            onAppliedChange(removeGroupByPart(query, partIndex));\n          }}\n        />\n      </SectionWrap>\n      <SectionWrap initialName=\"timezone\">\n        <InputSection\n          placeholder=\"(optional)\"\n          value={query.tz}\n          onChange={(tz) => {\n            onAppliedChange({ ...query, tz });\n          }}\n        />\n        <SectionLabel name=\"order by time\" />\n        <OrderByTimeSection\n          value={query.orderByTime === 'DESC' ? 'DESC' : 'ASC' /* FIXME: make this shared with influx_query_model */}\n          onChange={(v) => {\n            onAppliedChange({ ...query, orderByTime: v });\n          }}\n        />\n      </SectionWrap>\n      {/* query.fill is ignored in the query-editor, and it is deleted whenever\n          query-editor changes. the influx_query_model still handles it, but the new\n          approach seem to be to handle \"fill\" inside query.groupBy. so, if you\n          have a panel where in the json you have query.fill, it will be appled,\n          as long as you do not edit that query. */}\n      <SectionWrap initialName=\"limit\">\n        <InputSection\n          placeholder=\"(optional)\"\n          value={query.limit?.toString()}\n          onChange={(limit) => {\n            onAppliedChange({ ...query, limit });\n          }}\n        />\n        <SectionLabel name=\"slimit\" />\n        <InputSection\n          placeholder=\"(optional)\"\n          value={query.slimit?.toString()}\n          onChange={(slimit) => {\n            onAppliedChange({ ...query, slimit });\n          }}\n        />\n      </SectionWrap>\n      <SectionWrap initialName=\"format as\">\n        <FormatAsSection\n          format={query.resultFormat ?? DEFAULT_RESULT_FORMAT}\n          onChange={(format) => {\n            onAppliedChange({ ...query, resultFormat: format });\n          }}\n        />\n        {query.resultFormat !== 'table' && (\n          <>\n            <SectionLabel name=\"alias\" />\n            <InputSection\n              isWide\n              placeholder=\"Naming pattern\"\n              value={query.alias}\n              onChange={(alias) => {\n                onAppliedChange({ ...query, alias });\n              }}\n            />\n          </>\n        )}\n      </SectionWrap>\n    </div>\n  );\n};\n","import React, { useEffect, useState } from 'react';\nimport { Button, ConfirmModal } from '@grafana/ui';\n\ntype Props = {\n  isRaw: boolean;\n  onChange: (newIsRaw: boolean) => void;\n};\n\nexport const QueryEditorModeSwitcher = ({ isRaw, onChange }: Props): JSX.Element => {\n  const [isModalOpen, setModalOpen] = useState(false);\n\n  useEffect(() => {\n    // if the isRaw changes, we hide the modal\n    setModalOpen(false);\n  }, [isRaw]);\n\n  if (isRaw) {\n    return (\n      <>\n        <Button\n          icon=\"pen\"\n          variant=\"secondary\"\n          type=\"button\"\n          onClick={() => {\n            // we show the are-you-sure modal\n            setModalOpen(true);\n          }}\n        ></Button>\n        <ConfirmModal\n          isOpen={isModalOpen}\n          title=\"Switch to visual editor mode\"\n          body=\"Are you sure to switch to visual editor mode? You will loose the changes done in raw query mode.\"\n          confirmText=\"Yes, switch to editor mode\"\n          dismissText=\"No, stay in raw query mode\"\n          onConfirm={() => {\n            onChange(false);\n          }}\n          onDismiss={() => {\n            setModalOpen(false);\n          }}\n        />\n      </>\n    );\n  } else {\n    return (\n      <Button\n        icon=\"pen\"\n        variant=\"secondary\"\n        type=\"button\"\n        onClick={() => {\n          onChange(true);\n        }}\n      ></Button>\n    );\n  }\n};\n","import React from 'react';\n\nconst CHEAT_SHEET_ITEMS = [\n  {\n    title: 'Getting started',\n    label:\n      'Start by selecting a measurement and field from the dropdown above. You can then use the tag selector to further narrow your search.',\n  },\n];\n\nconst InfluxCheatSheet = (props: any) => (\n  <div>\n    <h2>InfluxDB Cheat Sheet</h2>\n    {CHEAT_SHEET_ITEMS.map((item) => (\n      <div className=\"cheat-sheet-item\" key={item.title}>\n        <div className=\"cheat-sheet-item__title\">{item.title}</div>\n        <div className=\"cheat-sheet-item__label\">{item.label}</div>\n      </div>\n    ))}\n  </div>\n);\n\nexport default InfluxCheatSheet;\n","import React, { PureComponent } from 'react';\nimport { QueryEditorHelpProps } from '@grafana/data';\nimport InfluxCheatSheet from './InfluxCheatSheet';\n\nexport default class InfluxStartPage extends PureComponent<QueryEditorHelpProps> {\n  render() {\n    return <InfluxCheatSheet onClickExample={this.props.onClickExample} />;\n  }\n}\n","import React, { PureComponent } from 'react';\nimport {\n  DataSourcePluginOptionsEditorProps,\n  SelectableValue,\n  onUpdateDatasourceOption,\n  updateDatasourcePluginResetOption,\n  onUpdateDatasourceJsonDataOption,\n  onUpdateDatasourceJsonDataOptionSelect,\n  onUpdateDatasourceSecureJsonDataOption,\n  updateDatasourcePluginJsonDataOption,\n} from '@grafana/data';\nimport { Alert, DataSourceHttpSettings, InfoBox, InlineField, InlineFormLabel, LegacyForms } from '@grafana/ui';\nconst { Select, Input, SecretFormField } = LegacyForms;\nimport { InfluxOptions, InfluxSecureJsonData, InfluxVersion } from '../types';\n\nconst httpModes = [\n  { label: 'GET', value: 'GET' },\n  { label: 'POST', value: 'POST' },\n] as SelectableValue[];\n\nconst versions = [\n  {\n    label: 'InfluxQL',\n    value: InfluxVersion.InfluxQL,\n    description: 'The InfluxDB SQL-like query language.  Supported in InfluxDB 1.x',\n  },\n  {\n    label: 'Flux',\n    value: InfluxVersion.Flux,\n    description: 'Advanced data scripting and query language.  Supported in InfluxDB 2.x and 1.8+ (beta)',\n  },\n] as Array<SelectableValue<InfluxVersion>>;\n\nexport type Props = DataSourcePluginOptionsEditorProps<InfluxOptions>;\ntype State = {\n  maxSeries: string | undefined;\n};\n\nexport class ConfigEditor extends PureComponent<Props, State> {\n  state = {\n    maxSeries: '',\n  };\n\n  constructor(props: Props) {\n    super(props);\n    this.state.maxSeries = props.options.jsonData.maxSeries?.toString() || '';\n  }\n\n  // 1x\n  onResetPassword = () => {\n    updateDatasourcePluginResetOption(this.props, 'password');\n  };\n\n  // 2x\n  onResetToken = () => {\n    updateDatasourcePluginResetOption(this.props, 'token');\n  };\n\n  onVersionChanged = (selected: SelectableValue<InfluxVersion>) => {\n    const { options, onOptionsChange } = this.props;\n\n    const copy: any = {\n      ...options,\n      jsonData: {\n        ...options.jsonData,\n        version: selected.value,\n      },\n    };\n    if (selected.value === InfluxVersion.Flux) {\n      copy.access = 'proxy';\n      copy.basicAuth = true;\n      copy.jsonData.httpMode = 'POST';\n\n      // Remove old 1x configs\n      delete copy.user;\n      delete copy.database;\n    }\n\n    onOptionsChange(copy);\n  };\n\n  renderInflux2x() {\n    const { options } = this.props;\n    const { secureJsonFields } = options;\n    const secureJsonData = (options.secureJsonData || {}) as InfluxSecureJsonData;\n\n    return (\n      <>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel className=\"width-10\">Organization</InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-20\"\n                value={options.jsonData.organization || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'organization')}\n              />\n            </div>\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <SecretFormField\n              isConfigured={(secureJsonFields && secureJsonFields.token) as boolean}\n              value={secureJsonData.token || ''}\n              label=\"Token\"\n              labelWidth={10}\n              inputWidth={20}\n              onReset={this.onResetToken}\n              onChange={onUpdateDatasourceSecureJsonDataOption(this.props, 'token')}\n            />\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel className=\"width-10\">Default Bucket</InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-20\"\n                placeholder=\"default bucket\"\n                value={options.jsonData.defaultBucket || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'defaultBucket')}\n              />\n            </div>\n          </div>\n        </div>\n\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              className=\"width-10\"\n              tooltip=\"A lower limit for the auto group by time interval. Recommended to be set to write frequency,\n\t\t\t\tfor example 1m if your data is written every minute.\"\n            >\n              Min time interval\n            </InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-10\"\n                placeholder=\"10s\"\n                value={options.jsonData.timeInterval || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'timeInterval')}\n              />\n            </div>\n          </div>\n        </div>\n      </>\n    );\n  }\n\n  renderInflux1x() {\n    const { options } = this.props;\n    const { secureJsonFields } = options;\n    const secureJsonData = (options.secureJsonData || {}) as InfluxSecureJsonData;\n\n    return (\n      <>\n        <InfoBox>\n          <h5>Database Access</h5>\n          <p>\n            Setting the database for this datasource does not deny access to other databases. The InfluxDB query syntax\n            allows switching the database in the query. For example:\n            <code>SHOW MEASUREMENTS ON _internal</code> or\n            <code>SELECT * FROM &quot;_internal&quot;..&quot;database&quot; LIMIT 10</code>\n            <br />\n            <br />\n            To support data isolation and security, make sure appropriate permissions are configured in InfluxDB.\n          </p>\n        </InfoBox>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel className=\"width-10\">Database</InlineFormLabel>\n            <div className=\"width-20\">\n              <Input\n                className=\"width-20\"\n                value={options.database || ''}\n                onChange={onUpdateDatasourceOption(this.props, 'database')}\n              />\n            </div>\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel className=\"width-10\">User</InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-20\"\n                value={options.user || ''}\n                onChange={onUpdateDatasourceOption(this.props, 'user')}\n              />\n            </div>\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <SecretFormField\n              isConfigured={(secureJsonFields && secureJsonFields.password) as boolean}\n              value={secureJsonData.password || ''}\n              label=\"Password\"\n              labelWidth={10}\n              inputWidth={20}\n              onReset={this.onResetPassword}\n              onChange={onUpdateDatasourceSecureJsonDataOption(this.props, 'password')}\n            />\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              className=\"width-10\"\n              tooltip=\"You can use either GET or POST HTTP method to query your InfluxDB database. The POST\n          method allows you to perform heavy requests (with a lots of WHERE clause) while the GET method\n          will restrict you and return an error if the query is too large.\"\n            >\n              HTTP Method\n            </InlineFormLabel>\n            <Select\n              menuShouldPortal\n              className=\"width-10\"\n              value={httpModes.find((httpMode) => httpMode.value === options.jsonData.httpMode)}\n              options={httpModes}\n              defaultValue={options.jsonData.httpMode}\n              onChange={onUpdateDatasourceJsonDataOptionSelect(this.props, 'httpMode')}\n            />\n          </div>\n        </div>\n\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              className=\"width-10\"\n              tooltip=\"A lower limit for the auto group by time interval. Recommended to be set to write frequency,\n\t\t\t\tfor example 1m if your data is written every minute.\"\n            >\n              Min time interval\n            </InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-10\"\n                placeholder=\"10s\"\n                value={options.jsonData.timeInterval || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'timeInterval')}\n              />\n            </div>\n          </div>\n        </div>\n      </>\n    );\n  }\n\n  render() {\n    const { options, onOptionsChange } = this.props;\n\n    return (\n      <>\n        <h3 className=\"page-heading\">Query Language</h3>\n        <div className=\"gf-form-group\">\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <Select\n                menuShouldPortal\n                className=\"width-30\"\n                value={options.jsonData.version === InfluxVersion.Flux ? versions[1] : versions[0]}\n                options={versions}\n                defaultValue={versions[0]}\n                onChange={this.onVersionChanged}\n              />\n            </div>\n          </div>\n        </div>\n\n        {options.jsonData.version === InfluxVersion.Flux && (\n          <InfoBox>\n            <h5>Support for Flux in Grafana is currently in beta</h5>\n            <p>\n              Please report any issues to: <br />\n              <a href=\"https://github.com/grafana/grafana/issues/new/choose\">\n                https://github.com/grafana/grafana/issues\n              </a>\n            </p>\n          </InfoBox>\n        )}\n\n        {options.access === 'direct' && (\n          <Alert title=\"Deprecation Notice\" severity=\"warning\">\n            Browser access mode in the InfluxDB datasource is deprecated and will be removed in a future release.\n          </Alert>\n        )}\n\n        <DataSourceHttpSettings\n          showAccessOptions={true}\n          dataSourceConfig={options}\n          defaultUrl=\"http://localhost:8086\"\n          onChange={onOptionsChange}\n        />\n\n        <div className=\"gf-form-group\">\n          <div>\n            <h3 className=\"page-heading\">InfluxDB Details</h3>\n          </div>\n          {options.jsonData.version === InfluxVersion.Flux ? this.renderInflux2x() : this.renderInflux1x()}\n          <div className=\"gf-form-inline\">\n            <InlineField\n              labelWidth={20}\n              label=\"Max series\"\n              tooltip=\"Limit the number of series/tables that Grafana will process. Lower this number to prevent abuse, and increase it if you have lots of small time series and not all are shown. Defaults to 1000.\"\n            >\n              <Input\n                placeholder=\"1000\"\n                type=\"number\"\n                className=\"width-10\"\n                value={this.state.maxSeries}\n                onChange={(event) => {\n                  // We duplicate this state so that we allow to write freely inside the input. We don't have\n                  // any influence over saving so this seems to be only way to do this.\n                  this.setState({ maxSeries: event.currentTarget.value });\n                  const val = parseInt(event.currentTarget.value, 10);\n                  updateDatasourcePluginJsonDataOption(this.props, 'maxSeries', Number.isFinite(val) ? val : undefined);\n                }}\n              />\n            </InlineField>\n          </div>\n        </div>\n      </>\n    );\n  }\n}\n\nexport default ConfigEditor;\n","import React, { PureComponent } from 'react';\nimport InfluxDatasource from '../datasource';\nimport { InlineFormLabel, TextArea } from '@grafana/ui';\nimport { FluxQueryEditor } from './FluxQueryEditor';\n\ninterface Props {\n  query: string; // before flux, it was always a string\n  onChange: (query?: string) => void;\n  datasource: InfluxDatasource;\n}\n\nexport default class VariableQueryEditor extends PureComponent<Props> {\n  onRefresh = () => {\n    // noop\n  };\n\n  render() {\n    let { query, datasource, onChange } = this.props;\n    if (datasource.isFlux) {\n      return (\n        <FluxQueryEditor\n          datasource={datasource}\n          query={{\n            refId: 'A',\n            query,\n          }}\n          onRunQuery={this.onRefresh}\n          onChange={(v) => onChange(v.query)}\n        />\n      );\n    }\n\n    return (\n      <div className=\"gf-form-inline\">\n        <InlineFormLabel width={10}>Query</InlineFormLabel>\n        <div className=\"gf-form-inline gf-form--grow\">\n          <TextArea\n            defaultValue={query || ''}\n            placeholder=\"metric name or tags query\"\n            rows={1}\n            className=\"gf-form-input\"\n            onBlur={(e) => onChange(e.currentTarget.value)}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n","import InfluxDatasource from './datasource';\nimport { QueryEditor } from './components/QueryEditor';\nimport InfluxStartPage from './components/InfluxStartPage';\nimport { DataSourcePlugin } from '@grafana/data';\nimport ConfigEditor from './components/ConfigEditor';\nimport VariableQueryEditor from './components/VariableQueryEditor';\n\nclass InfluxAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(InfluxDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setQueryEditor(QueryEditor)\n  .setAnnotationQueryCtrl(InfluxAnnotationsQueryCtrl)\n  .setVariableQueryEditor(VariableQueryEditor)\n  .setQueryEditorHelp(InfluxStartPage);\n","import React from 'react';\nimport { css } from '@emotion/css';\nimport { QueryEditorProps } from '@grafana/data';\nimport { InfluxOptions, InfluxQuery } from '../types';\nimport InfluxDatasource from '../datasource';\nimport { FluxQueryEditor } from './FluxQueryEditor';\nimport { RawInfluxQLEditor } from './RawInfluxQLEditor';\nimport { Editor as VisualInfluxQLEditor } from './VisualInfluxQLEditor/Editor';\nimport { QueryEditorModeSwitcher } from './QueryEditorModeSwitcher';\nimport { buildRawQuery } from '../queryUtils';\n\ntype Props = QueryEditorProps<InfluxDatasource, InfluxQuery, InfluxOptions>;\n\nexport const QueryEditor = ({ query, onChange, onRunQuery, datasource, range, data }: Props): JSX.Element => {\n  if (datasource.isFlux) {\n    return (\n      <div className=\"gf-form-query-content\">\n        <FluxQueryEditor query={query} onChange={onChange} onRunQuery={onRunQuery} datasource={datasource} />\n      </div>\n    );\n  }\n\n  return (\n    <div className={css({ display: 'flex' })}>\n      <div className={css({ flexGrow: 1 })}>\n        {query.rawQuery ? (\n          <RawInfluxQLEditor query={query} onChange={onChange} onRunQuery={onRunQuery} />\n        ) : (\n          <VisualInfluxQLEditor query={query} onChange={onChange} onRunQuery={onRunQuery} datasource={datasource} />\n        )}\n      </div>\n      <QueryEditorModeSwitcher\n        isRaw={query.rawQuery ?? false}\n        onChange={(value) => {\n          onChange({ ...query, query: buildRawQuery(query), rawQuery: value });\n          onRunQuery();\n        }}\n      />\n    </div>\n  );\n};\n","import { useEffect, useRef } from 'react';\nvar usePrevious = function (state) {\n    var ref = useRef();\n    useEffect(function () {\n        ref.current = state;\n    });\n    return ref.current;\n};\nexport default usePrevious;\n"],"sourceRoot":""}